Index: app/src/main/java/com/example/andapp1/MessageRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//MessageRepository.kt\npackage com.example.andapp1\n\nimport android.R.attr.text\nimport android.R.id.message\nimport android.util.Log\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport com.google.firebase.database.*\nimport java.util.*\nimport okhttp3.MediaType.Companion.toMediaType\nimport okhttp3.RequestBody.Companion.toRequestBody\n\nclass MessageRepository(private val roomCode: String) {\n    private val messagesRef: DatabaseReference =\n        FirebaseDatabase.getInstance().getReference(\"messages\").child(roomCode)\n\n    private val usersRef: DatabaseReference =\n        FirebaseDatabase.getInstance().getReference(\"users\")\n\n    private val _messages = MutableLiveData<List<ChatMessage>>()\n    val messages: LiveData<List<ChatMessage>> = _messages\n    private var lastMessageSnapshot: List<ChatMessage> = emptyList()\n\n    private val messageListener = object : ValueEventListener {\n        override fun onDataChange(snapshot: DataSnapshot) {\n            val messageList = mutableListOf<ChatMessage>()\n            val userIds = mutableSetOf<String>()\n            // 1) 메시지 수집 및 사용자 ID 추출\n            for (child in snapshot.children) {\n                child.getValue(ChatMessage::class.java)?.let { message ->\n                    if (message.getText().isNotBlank() || message.imageUrl != null) {\n                        messageList.add(message)\n                        userIds.add(message.getUser().getId())\n                    }\n                }\n            }\n\n\n            // 2) 사용자별 프로필 이미지 로드\n            loadUserProfiles(userIds) { userProfiles ->\n\n                // 3) 메시지에 프로필 이미지 매핑\n                val updatedMessages = messageList.map { message ->\n                    val userId = message.getUser().getId()\n                    val profileImageUrl = userProfiles[userId]\n                    // Author에 프로필 이미지 설정\n                    val updatedAuthor = Author(\n                        id = message.getUser().getId(),\n                        name = message.getUser().getName(),\n                        avatar = profileImageUrl\n                    )\n\n\n                    // 새로운 ChatMessage 생성 (기존 데이터 유지 + 프로필 이미지 추가)\n                    ChatMessage(\n                        messageId = message.messageId,\n                        text = message.getText(),\n                        user = updatedAuthor,\n                        imageUrlValue = message.imageUrlValue,\n                        mapUrl = message.getMapUrl(),\n                        createdAt = message.getCreatedAt()\n                    )\n                }\n\n                val sortedMessages = updatedMessages.sortedBy { it.createdAt.time }\n\n                if (!isSameMessageList(lastMessageSnapshot, sortedMessages)) {\n                    lastMessageSnapshot = sortedMessages\n                    _messages.postValue(sortedMessages)\n                    Log.d(\"MessageRepository\", \"✅ LiveData 갱신됨 (프로필 이미지 포함) → size = ${sortedMessages.size}\")\n                } else {\n                    Log.d(\"MessageRepository\", \"⚠ 중복 메시지 무시됨 (LiveData 발행 안 함)\")\n                }\n            }\n        }\n\n        override fun onCancelled(error: DatabaseError) {\n            Log.e(\"MessageRepository\", \"Firebase 오류: ${error.message}\")\n        }\n    }\n\n    // 사용자 프로필 이미지 일괄 로드\n    private fun loadUserProfiles(userIds: Set<String>, callback: (Map<String, String?>) -> Unit) {\n        if (userIds.isEmpty()) {\n            Log.d(\"ProfileDebug\", \"사용자 ID가 없어서 프로필 로드 생략\")\n            callback(emptyMap())\n            return\n        }\n\n\n        val userProfiles = mutableMapOf<String, String?>()\n        var loadedCount = 0\n\n        for (userId in userIds) {\n\n            usersRef.child(userId).child(\"profileImageUrl\").get()\n                .addOnSuccessListener { snapshot ->\n                    val profileUrl = snapshot.getValue(String::class.java)\n                    userProfiles[userId] = profileUrl\n                    loadedCount++\n\n\n                    if (loadedCount == userIds.size) {\n                        callback(userProfiles)\n                    }\n                }\n                .addOnFailureListener { error ->\n                    userProfiles[userId] = null // 실패 시 null로 설정\n                    loadedCount++\n\n                    if (loadedCount == userIds.size) {\n                        Log.d(\"ProfileDebug\", \"프로필 로드 완료 (일부 실패 포함): $userProfiles\")\n                        callback(userProfiles)\n                    }\n                }\n        }\n    }\n\n    init {\n        messagesRef.addListenerForSingleValueEvent(object : ValueEventListener {\n            override fun onDataChange(snapshot: DataSnapshot) {\n                Log.d(\"MessageRepo\", \"방 존재 여부: ${snapshot.exists()}\")\n                if (!snapshot.exists()) {\n                    Log.d(\"MessageRepo\", \"초기화 생략됨 (불필요한 빈 메시지 방지)\")\n                }\n            }\n            override fun onCancelled(error: DatabaseError) {\n                Log.e(\"MessageRepo\", \"Firebase 오류: ${error.message}\")\n            }\n        })\n\n        messagesRef.addValueEventListener(messageListener)\n    }\n\n    fun sendMessage(message: ChatMessage) {\n        val messageId = messagesRef.push().key ?: UUID.randomUUID().toString()\n        message.messageId = messageId\n        messagesRef.child(messageId).setValue(message)\n        Log.d(\"MessageRepository\", \"✅ Firebase 저장 완료: ${message.text}\")\n\n        // === \uD83D\uDD14 최신 OkHttp 방식 ===\n        try {\n            val json = org.json.JSONObject().apply {\n                put(\"roomId\", roomCode)\n                put(\"senderId\", message.user.id)\n                put(\"senderName\", message.user.name)\n                put(\"messageText\", message.text ?: \"\")\n            }\n\n            // 최신 확장 함수 사용!\n            val mediaType = \"application/json; charset=utf-8\".toMediaType()\n            val body = json.toString().toRequestBody(mediaType)\n\n            val request = okhttp3.Request.Builder()\n                .url(\"https://us-central1-andapp1-bcb40.cloudfunctions.net/sendChatNotification\")\n                .post(body)\n                .build()\n\n            okhttp3.OkHttpClient().newCall(request).enqueue(object : okhttp3.Callback {\n                override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {\n                    Log.e(\"푸시알림\", \"알림 함수 호출 실패\", e)\n                }\n\n                override fun onResponse(call: okhttp3.Call, response: okhttp3.Response) {\n                    val resBody = response.body?.string() // ✅ .body() → .body\n                    Log.d(\"푸시알림\", \"알림 함수 응답: $resBody\")\n                }\n            })\n        } catch (e: Exception) {\n            Log.e(\"푸시알림\", \"알림 함수 호출 중 예외\", e)\n        }\n    }\n\n    fun cleanup() {\n        messagesRef.removeEventListener(messageListener)\n    }\n\n    private fun isSameMessageList(\n        list1: List<ChatMessage>,\n        list2: List<ChatMessage>\n    ): Boolean {\n        if (list1.size != list2.size) return false\n        return list1.zip(list2).all { (a, b) -> a.id == b.id }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/MessageRepository.kt b/app/src/main/java/com/example/andapp1/MessageRepository.kt
--- a/app/src/main/java/com/example/andapp1/MessageRepository.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/MessageRepository.kt	(date 1749647755248)
@@ -7,9 +7,14 @@
 import androidx.lifecycle.LiveData
 import androidx.lifecycle.MutableLiveData
 import com.google.firebase.database.*
-import java.util.*
+import kotlinx.coroutines.CoroutineScope
+import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.tasks.await
+import kotlinx.coroutines.withContext
 import okhttp3.MediaType.Companion.toMediaType
 import okhttp3.RequestBody.Companion.toRequestBody
+import java.util.*
 
 class MessageRepository(private val roomCode: String) {
     private val messagesRef: DatabaseReference =
@@ -20,135 +25,109 @@
 
     private val _messages = MutableLiveData<List<ChatMessage>>()
     val messages: LiveData<List<ChatMessage>> = _messages
-    private var lastMessageSnapshot: List<ChatMessage> = emptyList()
+
+    private val messageList = mutableListOf<ChatMessage>()
+    private val userProfileCache = mutableMapOf<String, String?>()
 
-    private val messageListener = object : ValueEventListener {
-        override fun onDataChange(snapshot: DataSnapshot) {
-            val messageList = mutableListOf<ChatMessage>()
-            val userIds = mutableSetOf<String>()
-            // 1) 메시지 수집 및 사용자 ID 추출
-            for (child in snapshot.children) {
-                child.getValue(ChatMessage::class.java)?.let { message ->
-                    if (message.getText().isNotBlank() || message.imageUrl != null) {
-                        messageList.add(message)
-                        userIds.add(message.getUser().getId())
+    private val messageListener = object : ChildEventListener {
+        override fun onChildAdded(snapshot: DataSnapshot, previousChildName: String?) {
+            val message = snapshot.getValue(ChatMessage::class.java)
+            if (message != null && (message.getText().isNotBlank() || message.imageUrl != null)) {
+                CoroutineScope(Dispatchers.IO).launch {
+                    val author = getAuthorWithProfile(message.getUser())
+                    val updatedMessage = message.copy(user = author, messageId = snapshot.key ?: message.id)
+                    
+                    withContext(Dispatchers.Main) {
+                        messageList.add(updatedMessage)
+                        messageList.sortBy { it.createdAt.time }
+                        _messages.value = messageList.toList()
+                        Log.d("MessageRepository", "✅ New message added and UI updated.")
                     }
                 }
             }
-
-
-            // 2) 사용자별 프로필 이미지 로드
-            loadUserProfiles(userIds) { userProfiles ->
-
-                // 3) 메시지에 프로필 이미지 매핑
-                val updatedMessages = messageList.map { message ->
-                    val userId = message.getUser().getId()
-                    val profileImageUrl = userProfiles[userId]
-                    // Author에 프로필 이미지 설정
-                    val updatedAuthor = Author(
-                        id = message.getUser().getId(),
-                        name = message.getUser().getName(),
-                        avatar = profileImageUrl
-                    )
-
-
-                    // 새로운 ChatMessage 생성 (기존 데이터 유지 + 프로필 이미지 추가)
-                    ChatMessage(
-                        messageId = message.messageId,
-                        text = message.getText(),
-                        user = updatedAuthor,
-                        imageUrlValue = message.imageUrlValue,
-                        mapUrl = message.getMapUrl(),
-                        createdAt = message.getCreatedAt()
-                    )
-                }
+        }
 
-                val sortedMessages = updatedMessages.sortedBy { it.createdAt.time }
+        override fun onChildChanged(snapshot: DataSnapshot, previousChildName: String?) {
+            val message = snapshot.getValue(ChatMessage::class.java)
+            if (message != null) {
+                CoroutineScope(Dispatchers.IO).launch {
+                    val author = getAuthorWithProfile(message.getUser())
+                    val updatedMessage = message.copy(user = author, messageId = snapshot.key ?: message.id)
 
-                if (!isSameMessageList(lastMessageSnapshot, sortedMessages)) {
-                    lastMessageSnapshot = sortedMessages
-                    _messages.postValue(sortedMessages)
-                    Log.d("MessageRepository", "✅ LiveData 갱신됨 (프로필 이미지 포함) → size = ${sortedMessages.size}")
-                } else {
-                    Log.d("MessageRepository", "⚠ 중복 메시지 무시됨 (LiveData 발행 안 함)")
+                    withContext(Dispatchers.Main) {
+                        val index = messageList.indexOfFirst { it.id == updatedMessage.id }
+                        if (index != -1) {
+                            messageList[index] = updatedMessage
+                            messageList.sortBy { it.createdAt.time }
+                            _messages.value = messageList.toList()
+                        }
+                    }
                 }
             }
         }
 
+        override fun onChildRemoved(snapshot: DataSnapshot) {
+            val messageId = snapshot.key
+            val index = messageList.indexOfFirst { it.id == messageId }
+            if (index != -1) {
+                messageList.removeAt(index)
+                _messages.value = messageList.toList()
+            }
+        }
+        
         override fun onCancelled(error: DatabaseError) {
-            Log.e("MessageRepository", "Firebase 오류: ${error.message}")
+            Log.e("MessageRepository", "Firebase message listener error: ${error.message}")
+        }
+        
+        override fun onChildMoved(snapshot: DataSnapshot, previousChildName: String?) {
+            // Not implemented
         }
     }
 
-    // 사용자 프로필 이미지 일괄 로드
-    private fun loadUserProfiles(userIds: Set<String>, callback: (Map<String, String?>) -> Unit) {
-        if (userIds.isEmpty()) {
-            Log.d("ProfileDebug", "사용자 ID가 없어서 프로필 로드 생략")
-            callback(emptyMap())
-            return
+    private suspend fun getAuthorWithProfile(author: Author): Author {
+        val userId = author.getId()
+        if (userProfileCache.containsKey(userId)) {
+            return author.copy(avatar = userProfileCache[userId])
         }
-
-
-        val userProfiles = mutableMapOf<String, String?>()
-        var loadedCount = 0
-
-        for (userId in userIds) {
-
-            usersRef.child(userId).child("profileImageUrl").get()
-                .addOnSuccessListener { snapshot ->
-                    val profileUrl = snapshot.getValue(String::class.java)
-                    userProfiles[userId] = profileUrl
-                    loadedCount++
-
-
-                    if (loadedCount == userIds.size) {
-                        callback(userProfiles)
-                    }
-                }
-                .addOnFailureListener { error ->
-                    userProfiles[userId] = null // 실패 시 null로 설정
-                    loadedCount++
-
-                    if (loadedCount == userIds.size) {
-                        Log.d("ProfileDebug", "프로필 로드 완료 (일부 실패 포함): $userProfiles")
-                        callback(userProfiles)
-                    }
-                }
+        
+        return try {
+            val snapshot = usersRef.child(userId).child("profileImageUrl").get().await()
+            val profileUrl = snapshot.getValue(String::class.java)
+            userProfileCache[userId] = profileUrl
+            author.copy(avatar = profileUrl)
+        } catch (e: Exception) {
+            Log.e("MessageRepository", "Failed to load profile for user $userId", e)
+            author // Return original author on failure
         }
     }
 
     init {
-        messagesRef.addListenerForSingleValueEvent(object : ValueEventListener {
-            override fun onDataChange(snapshot: DataSnapshot) {
-                Log.d("MessageRepo", "방 존재 여부: ${snapshot.exists()}")
-                if (!snapshot.exists()) {
-                    Log.d("MessageRepo", "초기화 생략됨 (불필요한 빈 메시지 방지)")
-                }
-            }
-            override fun onCancelled(error: DatabaseError) {
-                Log.e("MessageRepo", "Firebase 오류: ${error.message}")
-            }
-        })
-
-        messagesRef.addValueEventListener(messageListener)
+        messagesRef.addChildEventListener(messageListener)
     }
 
     fun sendMessage(message: ChatMessage) {
         val messageId = messagesRef.push().key ?: UUID.randomUUID().toString()
-        message.messageId = messageId
-        messagesRef.child(messageId).setValue(message)
-        Log.d("MessageRepository", "✅ Firebase 저장 완료: ${message.text}")
-
-        // === 🔔 최신 OkHttp 방식 ===
+        val messageToSend = message.copy(messageId = messageId)
+        
+        messagesRef.child(messageId).setValue(messageToSend)
+            .addOnSuccessListener {
+                Log.d("MessageRepository", "✅ Firebase message sent: ${message.text}")
+                sendPushNotification(messageToSend)
+            }
+            .addOnFailureListener {
+                Log.e("MessageRepository", "❌ Failed to send message.", it)
+            }
+    }
+    
+    private fun sendPushNotification(message: ChatMessage) {
         try {
             val json = org.json.JSONObject().apply {
                 put("roomId", roomCode)
                 put("senderId", message.user.id)
                 put("senderName", message.user.name)
-                put("messageText", message.text ?: "")
+                put("messageText", message.text ?: "이미지")
             }
 
-            // 최신 확장 함수 사용!
             val mediaType = "application/json; charset=utf-8".toMediaType()
             val body = json.toString().toRequestBody(mediaType)
 
@@ -159,28 +138,21 @@
 
             okhttp3.OkHttpClient().newCall(request).enqueue(object : okhttp3.Callback {
                 override fun onFailure(call: okhttp3.Call, e: java.io.IOException) {
-                    Log.e("푸시알림", "알림 함수 호출 실패", e)
+                    Log.e("PushNotification", "Failed to call notification function", e)
                 }
 
                 override fun onResponse(call: okhttp3.Call, response: okhttp3.Response) {
-                    val resBody = response.body?.string() // ✅ .body() → .body
-                    Log.d("푸시알림", "알림 함수 응답: $resBody")
+                    response.body?.string().let {
+                        Log.d("PushNotification", "Notification function response: $it")
+                    }
                 }
             })
         } catch (e: Exception) {
-            Log.e("푸시알림", "알림 함수 호출 중 예외", e)
+            Log.e("PushNotification", "Exception while sending notification", e)
         }
     }
 
     fun cleanup() {
         messagesRef.removeEventListener(messageListener)
     }
-
-    private fun isSameMessageList(
-        list1: List<ChatMessage>,
-        list2: List<ChatMessage>
-    ): Boolean {
-        if (list1.size != list2.size) return false
-        return list1.zip(list2).all { (a, b) -> a.id == b.id }
-    }
 }
\ No newline at end of file
Index: app/src/main/java/com/example/andapp1/MainActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.andapp1\n\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.net.Uri\nimport android.os.Bundle\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.andapp1.databinding.ActivityMainBinding\nimport com.google.firebase.ktx.Firebase\nimport com.google.firebase.database.ktx.database\nimport com.kakao.sdk.common.KakaoSdk\nimport android.util.Base64\nimport java.security.MessageDigest\nimport android.content.Context\nimport com.google.firebase.database.DataSnapshot\nimport com.google.firebase.database.DatabaseError\nimport com.google.firebase.database.FirebaseDatabase\nimport com.google.firebase.database.ValueEventListener\nimport android.content.res.ColorStateList\nimport android.graphics.Color\nimport android.graphics.drawable.GradientDrawable\nimport androidx.appcompat.app.AlertDialog\nimport android.content.ClipData\nimport android.content.ClipboardManager\nimport com.google.firebase.messaging.FirebaseMessaging\n\nclass MainActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityMainBinding\n    private lateinit var viewModel: MainViewModel\n    private lateinit var roomAdapter: RoomAdapter\n    private var roomsListener: ValueEventListener? = null\n    private var currentUserId: String? = null\n\n    private val MAX_ROOMS = 5\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        binding = ActivityMainBinding.inflate(layoutInflater)\n\n        // 카카오 SDK 초기화\n        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))\n        printKeyHash(this) // \uD83D\uDC48 여기서 호출\n\n        // 사용자 정보 확인\n        val prefs = getSharedPreferences(\"login\", MODE_PRIVATE)\n        currentUserId = prefs.getString(\"userId\", null)\n        val nickname = prefs.getString(\"nickname\", null)\n        val email = prefs.getString(\"email\", null)\n        val profileImage = prefs.getString(\"profileImageUrl\", null)\n\n        // 로그인 확인\n        if (currentUserId == null) {\n            startActivity(Intent(this, LoginActivity::class.java))\n            finish()\n            return\n        }\n\n        FirebaseMessaging.getInstance().token.addOnSuccessListener { token ->\n            FirebaseDatabase.getInstance().getReference(\"users\")\n                .child(currentUserId!!)\n                .child(\"fcmToken\")\n                .setValue(token)\n        }\n\n        setContentView(binding.root)\n\n        // \uD83C\uDFA8 버튼 색상 강제 설정\n        setupButtonColors()\n\n        // Firebase에 사용자 정보 저장\n        currentUserId?.let {\n            checkAndSaveUserInfo(it, nickname, email)\n            // ViewModel에 userId 설정\n            setupViewModel(it)\n        }\n\n        setupRecyclerView()\n        setupButtonClickListeners()\n        setupFirebaseListener()\n\n        // 디버깅용 해시키 출력\n        getHashKey(this)\n    }\n    fun printKeyHash(context: Context) {\n        try {\n            val info = context.packageManager.getPackageInfo(\n                context.packageName,\n                PackageManager.GET_SIGNATURES\n            )\n\n            info.signatures?.let { signatures ->\n                for (signature in signatures) {\n                    val md = MessageDigest.getInstance(\"SHA\")\n                    md.update(signature.toByteArray())\n                    val hashKey = Base64.encodeToString(md.digest(), Base64.NO_WRAP)\n                    Log.d(\"HashKey\", \"keyhash: $hashKey\")\n                }\n            }\n        } catch (e: Exception) {\n            Log.e(\"HashKey\", \"Error printing KeyHash: ${e.message}\")\n        }\n    }\n    private fun setupButtonColors() {\n        // 배경과 완전히 동일한 그라디언트 (background_gradient.xml과 같은 색상)\n        val backgroundGradient = GradientDrawable().apply {\n            colors = intArrayOf(\n                Color.parseColor(\"#4facfe\"),  // background_gradient_start\n                Color.parseColor(\"#0093E9\")   // background_gradient_end\n            )\n            orientation = GradientDrawable.Orientation.TOP_BOTTOM\n            cornerRadius = 12f * resources.displayMetrics.density\n        }\n        \n        // 입장하기 버튼 - 배경과 동일한 색상\n        binding.enterButton.background = backgroundGradient.constantState?.newDrawable()?.mutate()\n        binding.enterButton.setTextColor(Color.WHITE)\n\n        // 방 생성하기 버튼 - 배경과 동일한 색상\n        val backgroundGradient2 = GradientDrawable().apply {\n            colors = intArrayOf(\n                Color.parseColor(\"#4facfe\"),  // background_gradient_start\n                Color.parseColor(\"#0093E9\")   // background_gradient_end\n            )\n            orientation = GradientDrawable.Orientation.TOP_BOTTOM\n            cornerRadius = 12f * resources.displayMetrics.density\n        }\n        binding.createRoomButton.background = backgroundGradient2\n        binding.createRoomButton.setTextColor(Color.WHITE)\n\n        Log.d(\"MainActivity\", \"✅ 버튼 색상을 배경색과 동일하게 설정 완료\")\n    }\n\n    private fun setupViewModel(userId: String) {\n        val db = RoomDatabaseInstance.getInstance(applicationContext)\n        val factory = MainViewModelFactory(applicationContext)\n        viewModel = ViewModelProvider(this, factory)[MainViewModel::class.java]\n        viewModel.setCurrentUserId(userId)\n    }\n\n    private fun setupFirebaseListener() {\n        currentUserId?.let { userId ->\n            roomsListener = FirebaseRoomManager.roomsRef.addValueEventListener(object : ValueEventListener {\n                override fun onDataChange(snapshot: DataSnapshot) {\n                    Log.d(\"MainActivity\", \"✅ Firebase 데이터 변경 감지\")\n\n                    val rooms = mutableListOf<Room>()\n                    for (roomSnapshot in snapshot.children) {\n                        val participantsSnapshot = roomSnapshot.child(\"participants\")\n                        val isParticipant = participantsSnapshot.hasChild(userId)\n\n                        if (isParticipant) {\n                            val room = roomSnapshot.getValue(Room::class.java)\n                            room?.let {\n                                // 로컬 DB에서 즐겨찾기 상태 가져오기\n                                viewModel.checkFavoriteStatus(it)\n                                rooms.add(it)\n                            }\n                        }\n                    }\n\n                    Log.d(\"MainActivity\", \"참여 중인 방 개수: ${rooms.size}\")\n                    viewModel.updateRoomsList(rooms)\n                }\n\n                override fun onCancelled(error: DatabaseError) {\n                    Log.e(\"MainActivity\", \"❌ Firebase 읽기 실패: ${error.message}\")\n                    Toast.makeText(this@MainActivity, \"채팅방 목록을 불러올 수 없습니다.\", Toast.LENGTH_SHORT).show()\n                }\n            })\n        }\n    }\n\n    private fun setupRecyclerView() {\n        roomAdapter = RoomAdapter(\n            mutableListOf(),\n            onItemClick = { room ->\n                viewModel.updateLastActivityTime(room.roomCode, Util.getCurrentTime())\n\n                FirebaseRoomManager.ensureRoomExists(room) {\n                    val intent = Intent(this, ChatActivity::class.java)\n                    intent.putExtra(\"roomCode\", room.roomCode)\n                    intent.putExtra(\"roomName\", room.roomTitle)\n                    intent.putExtra(\"userId\", currentUserId)\n                    startActivity(intent)\n                }\n            },\n            onMenuChangeNameClick = { room ->\n                DialogHelper.showChangeNameDialog(this, room) { newName ->\n                    currentUserId?.let { userId ->\n                        val author = Author(userId, getSharedPreferences(\"login\", MODE_PRIVATE).getString(\"nickname\", \"Unknown\") ?: \"Unknown\")\n                        viewModel.changeRoomName(room.roomCode, newName, author)\n                    }\n                }\n            },\n            onMenuParticipantsClick = { room ->\n                DialogHelper.showParticipantsDialog(this, room.roomCode)\n            },\n\n            onMenuInviteCodeClick = { room ->  // ✅ 여기!\n                // 초대코드 다이얼로그 호출!\n                showInviteCodeDialog(room)\n            },\n\n            onMenuLeaveRoomClick = { room ->\n                DialogHelper.showLeaveRoomDialog(this) {\n                    currentUserId?.let { userId ->\n                        viewModel.leaveRoom(room.roomCode, userId)\n                    }\n                }\n            },\n            onFavoriteToggle = { room, isFavorite ->\n                room.isFavorite = isFavorite\n                val roomEntity = RoomEntity(\n                    roomCode = room.roomCode,\n                    roomTitle = room.roomTitle,\n                    lastActivityTime = room.lastActivityTime,\n                    isFavorite = isFavorite\n                )\n\n                if (isFavorite) {\n                    viewModel.insertFavoriteRoom(roomEntity)\n                } else {\n                    viewModel.deleteFavoriteRoom(roomEntity)\n                }\n\n                val msg = if (isFavorite) \"즐겨찾기 등록!\" else \"즐겨찾기 해제!\"\n                Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()\n            }\n        )\n\n        binding.roomsRecyclerView.layoutManager = LinearLayoutManager(this)\n        binding.roomsRecyclerView.adapter = roomAdapter\n\n        viewModel.rooms.observe(this) { updatedRooms ->\n            Log.d(\"MainActivity\", \"UI 업데이트 - 방 개수: ${updatedRooms.size}\")\n            val sortedRooms = updatedRooms\n                .sortedWith(compareByDescending<Room> { it.isFavorite }\n                    .thenByDescending { it.lastActivityTime })\n\n            roomAdapter.updateRooms(sortedRooms.toMutableList())\n        }\n    }\n\n    private fun setupButtonClickListeners() {\n        // 방 생성하기\n        binding.createRoomButton.setOnClickListener {\n            val currentRooms = viewModel.rooms.value ?: emptyList()\n            if (currentRooms.size >= MAX_ROOMS) {\n                Toast.makeText(this, \"최대 채팅방 개수(5개)를 초과했습니다.\", Toast.LENGTH_SHORT).show()\n                return@setOnClickListener\n            }\n\n            DialogHelper.showCreateRoomDialog(this) { roomName, currentTime ->\n                val roomCode = Util.generateRandomCode()\n                val roomLink = viewModel.generateRoomLink(roomCode)\n\n                currentUserId?.let { userId ->\n                    val newRoom = Room(\n                        roomCode = roomCode,\n                        roomTitle = roomName,\n                        lastActivityTime = currentTime,\n                        isFavorite = false\n                    )\n\n                    // Firebase에 방 생성과 동시에 참여자 추가\n                    viewModel.createRoomWithParticipant(newRoom, userId)\n\n                    val shareText = \"\"\"\n                        친구랑 같이 여행을 떠나요!-!\n                        초대 코드 : $roomCode\n                        초대 링크 : $roomLink\n                    \"\"\".trimIndent()\n\n                    val sendIntent = Intent().apply {\n                        action = Intent.ACTION_SEND\n                        putExtra(Intent.EXTRA_TEXT, shareText)\n                        type = \"text/plain\"\n                    }\n\n                    val shareIntent = Intent.createChooser(sendIntent, \"공유하기\")\n                    startActivity(shareIntent)\n                }\n            }\n        }\n\n        // 입장하기 버튼\n        binding.enterButton.setOnClickListener {\n            val input = binding.enterCodeOrLinkEditText.text.toString().trim().uppercase()\n            val currentRooms = viewModel.rooms.value ?: emptyList()\n\n            // ✅ 디버깅 로그 추가\n            Log.d(\"RoomJoin\", \"=== 채팅방 입장 디버깅 ===\")\n            Log.d(\"RoomJoin\", \"입력값: '$input'\")\n            Log.d(\"RoomJoin\", \"입력값 길이: ${input.length}\")\n            Log.d(\"RoomJoin\", \"isRoomCode 결과: ${viewModel.isRoomCode(input)}\")\n            Log.d(\"RoomJoin\", \"isRoomLink 결과: ${viewModel.isRoomLink(input)}\")\n\n            if (currentRooms.size >= MAX_ROOMS) {\n                Toast.makeText(this, \"최대 채팅방 개수(5개)를 초과했습니다.\", Toast.LENGTH_SHORT).show()\n                return@setOnClickListener\n            }\n\n            val roomCode = when {\n                viewModel.isRoomCode(input) -> {\n                    Log.d(\"RoomJoin\", \"✅ 코드로 인식됨: $input\")\n                    input\n                }\n                viewModel.isRoomLink(input) -> {\n                    val extracted = viewModel.extractRoomCodeFromLink(input)\n                    Log.d(\"RoomJoin\", \"✅ 링크에서 추출된 코드: $extracted\")\n                    extracted\n                }\n                else -> {\n                    Log.d(\"RoomJoin\", \"❌ 코드/링크 인식 실패\")\n                    null\n                }\n            }\n\n            Log.d(\"RoomJoin\", \"최종 roomCode: $roomCode\")\n\n            if (roomCode == null) {\n                Toast.makeText(this, \"올바른 코드 또는 링크를 입력해주세요.\", Toast.LENGTH_SHORT).show()\n                return@setOnClickListener\n            }\n\n            if (currentRooms.any { it.roomCode == roomCode }) {\n                Toast.makeText(this, \"이미 참여한 채팅방입니다.\", Toast.LENGTH_SHORT).show()\n                return@setOnClickListener\n            }\n\n            // Firebase에서 방 정보 확인 후 입장\n            FirebaseRoomManager.roomsRef.child(roomCode).get().addOnSuccessListener { snapshot ->\n                Log.d(\"RoomJoin\", \"Firebase 조회 결과 - 방 존재: ${snapshot.exists()}\")\n                if (snapshot.exists()) {\n                    val room = snapshot.getValue(Room::class.java)\n                    room?.let {\n                        currentUserId?.let { userId ->\n                            // 참여자로 추가\n                            FirebaseRoomManager.addParticipant(roomCode, userId)\n                            Toast.makeText(this, \"채팅방에 입장했습니다.\", Toast.LENGTH_SHORT).show()\n                            binding.enterCodeOrLinkEditText.text.clear()\n                        }\n                    }\n                } else {\n                    Toast.makeText(this, \"존재하지 않는 채팅방입니다.\", Toast.LENGTH_SHORT).show()\n                }\n            }.addOnFailureListener { error ->\n                Log.e(\"RoomJoin\", \"Firebase 오류: ${error.message}\")\n                Toast.makeText(this, \"채팅방 확인에 실패했습니다.\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n\n    private fun checkAndSaveUserInfo(userId: String, nickname: String?, email: String?) {\n        val userRef = FirebaseDatabase.getInstance().getReference(\"users\").child(userId)\n\n        userRef.get().addOnSuccessListener { snapshot ->\n            if (!snapshot.exists()) {\n                val userMap = hashMapOf(\n                    \"id\" to userId,\n                    \"nickname\" to (nickname ?: \"사용자\"),\n                    \"email\" to (email ?: \"\")\n                )\n                userRef.setValue(userMap)\n                Log.d(\"MainActivity\", \"사용자 정보 저장 완료\")\n            }\n        }.addOnFailureListener {\n            Log.e(\"MainActivity\", \"사용자 정보 조회 실패\", it)\n        }\n    }\n\n    private fun getHashKey(context: Context) {\n        try {\n            val info = context.packageManager.getPackageInfo(\n                context.packageName,\n                PackageManager.GET_SIGNATURES\n            )\n            info.signatures?.forEach { signature ->\n                val md = MessageDigest.getInstance(\"SHA\")\n                md.update(signature.toByteArray())\n                val hashKey = Base64.encodeToString(md.digest(), Base64.NO_WRAP)\n                Log.d(\"HashKey\", \"keyhash: $hashKey\")\n            }\n        } catch (e: Exception) {\n            Log.e(\"HashKey\", \"Error: ${e.message}\")\n        }\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        // 메모리 누수 방지를 위해 리스너 제거\n        roomsListener?.let {\n            FirebaseRoomManager.roomsRef.removeEventListener(it)\n        }\n    }\n\n    override fun onResume() {\n        super.onResume()\n        // 화면 복귀 시 목록 새로고침\n        currentUserId?.let { userId ->\n            viewModel.loadRooms(userId)\n        }\n\n        // \uD83C\uDFA8 화면 복귀 시에도 버튼 색상 재설정\n        setupButtonColors()\n    }\n\n    private fun showInviteCodeDialog(room: Room) {\n        val inviteCode = room.roomCode\n\n        AlertDialog.Builder(this)\n            .setTitle(\"초대 코드\")\n            .setMessage(\"\\n$inviteCode\")\n            .setPositiveButton(\"복사\") { dialog, _ ->\n                val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager\n                val clip = android.content.ClipData.newPlainText(\"roomCode\", inviteCode)\n                clipboard.setPrimaryClip(clip)\n                Toast.makeText(this, \"초대 코드가 복사되었습니다!\", Toast.LENGTH_SHORT).show()\n                dialog.dismiss()\n            }\n            .setNegativeButton(\"닫기\", null)\n            .show()\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/MainActivity.kt b/app/src/main/java/com/example/andapp1/MainActivity.kt
--- a/app/src/main/java/com/example/andapp1/MainActivity.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/MainActivity.kt	(date 1749652333127)
@@ -1,430 +1,39 @@
 package com.example.andapp1
 
 import android.content.Intent
-import android.content.pm.PackageManager
-import android.net.Uri
 import android.os.Bundle
-import android.util.Log
-import android.widget.Toast
+import androidx.activity.viewModels
 import androidx.appcompat.app.AppCompatActivity
-import androidx.lifecycle.ViewModelProvider
-import androidx.recyclerview.widget.LinearLayoutManager
+import androidx.lifecycle.lifecycleScope
 import com.example.andapp1.databinding.ActivityMainBinding
-import com.google.firebase.ktx.Firebase
-import com.google.firebase.database.ktx.database
-import com.kakao.sdk.common.KakaoSdk
-import android.util.Base64
-import java.security.MessageDigest
-import android.content.Context
-import com.google.firebase.database.DataSnapshot
-import com.google.firebase.database.DatabaseError
-import com.google.firebase.database.FirebaseDatabase
-import com.google.firebase.database.ValueEventListener
-import android.content.res.ColorStateList
-import android.graphics.Color
-import android.graphics.drawable.GradientDrawable
-import androidx.appcompat.app.AlertDialog
-import android.content.ClipData
-import android.content.ClipboardManager
-import com.google.firebase.messaging.FirebaseMessaging
+import dagger.hilt.android.AndroidEntryPoint
+import kotlinx.coroutines.flow.collectLatest
+import kotlinx.coroutines.launch
 
+@AndroidEntryPoint
 class MainActivity : AppCompatActivity() {
 
     private lateinit var binding: ActivityMainBinding
-    private lateinit var viewModel: MainViewModel
-    private lateinit var roomAdapter: RoomAdapter
-    private var roomsListener: ValueEventListener? = null
-    private var currentUserId: String? = null
-
-    private val MAX_ROOMS = 5
+    private val viewModel: MainViewModel by viewModels()
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
         binding = ActivityMainBinding.inflate(layoutInflater)
-
-        // 카카오 SDK 초기화
-        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))
-        printKeyHash(this) // 👈 여기서 호출
-
-        // 사용자 정보 확인
-        val prefs = getSharedPreferences("login", MODE_PRIVATE)
-        currentUserId = prefs.getString("userId", null)
-        val nickname = prefs.getString("nickname", null)
-        val email = prefs.getString("email", null)
-        val profileImage = prefs.getString("profileImageUrl", null)
-
-        // 로그인 확인
-        if (currentUserId == null) {
-            startActivity(Intent(this, LoginActivity::class.java))
-            finish()
-            return
-        }
-
-        FirebaseMessaging.getInstance().token.addOnSuccessListener { token ->
-            FirebaseDatabase.getInstance().getReference("users")
-                .child(currentUserId!!)
-                .child("fcmToken")
-                .setValue(token)
-        }
-
         setContentView(binding.root)
 
-        // 🎨 버튼 색상 강제 설정
-        setupButtonColors()
-
-        // Firebase에 사용자 정보 저장
-        currentUserId?.let {
-            checkAndSaveUserInfo(it, nickname, email)
-            // ViewModel에 userId 설정
-            setupViewModel(it)
-        }
-
-        setupRecyclerView()
-        setupButtonClickListeners()
-        setupFirebaseListener()
-
-        // 디버깅용 해시키 출력
-        getHashKey(this)
-    }
-    fun printKeyHash(context: Context) {
-        try {
-            val info = context.packageManager.getPackageInfo(
-                context.packageName,
-                PackageManager.GET_SIGNATURES
-            )
-
-            info.signatures?.let { signatures ->
-                for (signature in signatures) {
-                    val md = MessageDigest.getInstance("SHA")
-                    md.update(signature.toByteArray())
-                    val hashKey = Base64.encodeToString(md.digest(), Base64.NO_WRAP)
-                    Log.d("HashKey", "keyhash: $hashKey")
-                }
-            }
-        } catch (e: Exception) {
-            Log.e("HashKey", "Error printing KeyHash: ${e.message}")
-        }
-    }
-    private fun setupButtonColors() {
-        // 배경과 완전히 동일한 그라디언트 (background_gradient.xml과 같은 색상)
-        val backgroundGradient = GradientDrawable().apply {
-            colors = intArrayOf(
-                Color.parseColor("#4facfe"),  // background_gradient_start
-                Color.parseColor("#0093E9")   // background_gradient_end
-            )
-            orientation = GradientDrawable.Orientation.TOP_BOTTOM
-            cornerRadius = 12f * resources.displayMetrics.density
-        }
-        
-        // 입장하기 버튼 - 배경과 동일한 색상
-        binding.enterButton.background = backgroundGradient.constantState?.newDrawable()?.mutate()
-        binding.enterButton.setTextColor(Color.WHITE)
-
-        // 방 생성하기 버튼 - 배경과 동일한 색상
-        val backgroundGradient2 = GradientDrawable().apply {
-            colors = intArrayOf(
-                Color.parseColor("#4facfe"),  // background_gradient_start
-                Color.parseColor("#0093E9")   // background_gradient_end
-            )
-            orientation = GradientDrawable.Orientation.TOP_BOTTOM
-            cornerRadius = 12f * resources.displayMetrics.density
-        }
-        binding.createRoomButton.background = backgroundGradient2
-        binding.createRoomButton.setTextColor(Color.WHITE)
-
-        Log.d("MainActivity", "✅ 버튼 색상을 배경색과 동일하게 설정 완료")
-    }
-
-    private fun setupViewModel(userId: String) {
-        val db = RoomDatabaseInstance.getInstance(applicationContext)
-        val factory = MainViewModelFactory(applicationContext)
-        viewModel = ViewModelProvider(this, factory)[MainViewModel::class.java]
-        viewModel.setCurrentUserId(userId)
-    }
-
-    private fun setupFirebaseListener() {
-        currentUserId?.let { userId ->
-            roomsListener = FirebaseRoomManager.roomsRef.addValueEventListener(object : ValueEventListener {
-                override fun onDataChange(snapshot: DataSnapshot) {
-                    Log.d("MainActivity", "✅ Firebase 데이터 변경 감지")
-
-                    val rooms = mutableListOf<Room>()
-                    for (roomSnapshot in snapshot.children) {
-                        val participantsSnapshot = roomSnapshot.child("participants")
-                        val isParticipant = participantsSnapshot.hasChild(userId)
-
-                        if (isParticipant) {
-                            val room = roomSnapshot.getValue(Room::class.java)
-                            room?.let {
-                                // 로컬 DB에서 즐겨찾기 상태 가져오기
-                                viewModel.checkFavoriteStatus(it)
-                                rooms.add(it)
-                            }
-                        }
-                    }
-
-                    Log.d("MainActivity", "참여 중인 방 개수: ${rooms.size}")
-                    viewModel.updateRoomsList(rooms)
-                }
-
-                override fun onCancelled(error: DatabaseError) {
-                    Log.e("MainActivity", "❌ Firebase 읽기 실패: ${error.message}")
-                    Toast.makeText(this@MainActivity, "채팅방 목록을 불러올 수 없습니다.", Toast.LENGTH_SHORT).show()
-                }
-            })
-        }
-    }
-
-    private fun setupRecyclerView() {
-        roomAdapter = RoomAdapter(
-            mutableListOf(),
-            onItemClick = { room ->
-                viewModel.updateLastActivityTime(room.roomCode, Util.getCurrentTime())
-
-                FirebaseRoomManager.ensureRoomExists(room) {
-                    val intent = Intent(this, ChatActivity::class.java)
-                    intent.putExtra("roomCode", room.roomCode)
-                    intent.putExtra("roomName", room.roomTitle)
-                    intent.putExtra("userId", currentUserId)
-                    startActivity(intent)
-                }
-            },
-            onMenuChangeNameClick = { room ->
-                DialogHelper.showChangeNameDialog(this, room) { newName ->
-                    currentUserId?.let { userId ->
-                        val author = Author(userId, getSharedPreferences("login", MODE_PRIVATE).getString("nickname", "Unknown") ?: "Unknown")
-                        viewModel.changeRoomName(room.roomCode, newName, author)
-                    }
-                }
-            },
-            onMenuParticipantsClick = { room ->
-                DialogHelper.showParticipantsDialog(this, room.roomCode)
-            },
-
-            onMenuInviteCodeClick = { room ->  // ✅ 여기!
-                // 초대코드 다이얼로그 호출!
-                showInviteCodeDialog(room)
-            },
-
-            onMenuLeaveRoomClick = { room ->
-                DialogHelper.showLeaveRoomDialog(this) {
-                    currentUserId?.let { userId ->
-                        viewModel.leaveRoom(room.roomCode, userId)
-                    }
-                }
-            },
-            onFavoriteToggle = { room, isFavorite ->
-                room.isFavorite = isFavorite
-                val roomEntity = RoomEntity(
-                    roomCode = room.roomCode,
-                    roomTitle = room.roomTitle,
-                    lastActivityTime = room.lastActivityTime,
-                    isFavorite = isFavorite
-                )
-
-                if (isFavorite) {
-                    viewModel.insertFavoriteRoom(roomEntity)
-                } else {
-                    viewModel.deleteFavoriteRoom(roomEntity)
-                }
-
-                val msg = if (isFavorite) "즐겨찾기 등록!" else "즐겨찾기 해제!"
-                Toast.makeText(this, msg, Toast.LENGTH_SHORT).show()
-            }
-        )
-
-        binding.roomsRecyclerView.layoutManager = LinearLayoutManager(this)
-        binding.roomsRecyclerView.adapter = roomAdapter
-
-        viewModel.rooms.observe(this) { updatedRooms ->
-            Log.d("MainActivity", "UI 업데이트 - 방 개수: ${updatedRooms.size}")
-            val sortedRooms = updatedRooms
-                .sortedWith(compareByDescending<Room> { it.isFavorite }
-                    .thenByDescending { it.lastActivityTime })
-
-            roomAdapter.updateRooms(sortedRooms.toMutableList())
-        }
-    }
-
-    private fun setupButtonClickListeners() {
-        // 방 생성하기
-        binding.createRoomButton.setOnClickListener {
-            val currentRooms = viewModel.rooms.value ?: emptyList()
-            if (currentRooms.size >= MAX_ROOMS) {
-                Toast.makeText(this, "최대 채팅방 개수(5개)를 초과했습니다.", Toast.LENGTH_SHORT).show()
-                return@setOnClickListener
-            }
-
-            DialogHelper.showCreateRoomDialog(this) { roomName, currentTime ->
-                val roomCode = Util.generateRandomCode()
-                val roomLink = viewModel.generateRoomLink(roomCode)
-
-                currentUserId?.let { userId ->
-                    val newRoom = Room(
-                        roomCode = roomCode,
-                        roomTitle = roomName,
-                        lastActivityTime = currentTime,
-                        isFavorite = false
-                    )
-
-                    // Firebase에 방 생성과 동시에 참여자 추가
-                    viewModel.createRoomWithParticipant(newRoom, userId)
-
-                    val shareText = """
-                        친구랑 같이 여행을 떠나요!-!
-                        초대 코드 : $roomCode
-                        초대 링크 : $roomLink
-                    """.trimIndent()
-
-                    val sendIntent = Intent().apply {
-                        action = Intent.ACTION_SEND
-                        putExtra(Intent.EXTRA_TEXT, shareText)
-                        type = "text/plain"
-                    }
-
-                    val shareIntent = Intent.createChooser(sendIntent, "공유하기")
-                    startActivity(shareIntent)
-                }
-            }
-        }
-
-        // 입장하기 버튼
-        binding.enterButton.setOnClickListener {
-            val input = binding.enterCodeOrLinkEditText.text.toString().trim().uppercase()
-            val currentRooms = viewModel.rooms.value ?: emptyList()
-
-            // ✅ 디버깅 로그 추가
-            Log.d("RoomJoin", "=== 채팅방 입장 디버깅 ===")
-            Log.d("RoomJoin", "입력값: '$input'")
-            Log.d("RoomJoin", "입력값 길이: ${input.length}")
-            Log.d("RoomJoin", "isRoomCode 결과: ${viewModel.isRoomCode(input)}")
-            Log.d("RoomJoin", "isRoomLink 결과: ${viewModel.isRoomLink(input)}")
-
-            if (currentRooms.size >= MAX_ROOMS) {
-                Toast.makeText(this, "최대 채팅방 개수(5개)를 초과했습니다.", Toast.LENGTH_SHORT).show()
-                return@setOnClickListener
-            }
-
-            val roomCode = when {
-                viewModel.isRoomCode(input) -> {
-                    Log.d("RoomJoin", "✅ 코드로 인식됨: $input")
-                    input
-                }
-                viewModel.isRoomLink(input) -> {
-                    val extracted = viewModel.extractRoomCodeFromLink(input)
-                    Log.d("RoomJoin", "✅ 링크에서 추출된 코드: $extracted")
-                    extracted
-                }
-                else -> {
-                    Log.d("RoomJoin", "❌ 코드/링크 인식 실패")
-                    null
-                }
-            }
-
-            Log.d("RoomJoin", "최종 roomCode: $roomCode")
-
-            if (roomCode == null) {
-                Toast.makeText(this, "올바른 코드 또는 링크를 입력해주세요.", Toast.LENGTH_SHORT).show()
-                return@setOnClickListener
-            }
-
-            if (currentRooms.any { it.roomCode == roomCode }) {
-                Toast.makeText(this, "이미 참여한 채팅방입니다.", Toast.LENGTH_SHORT).show()
-                return@setOnClickListener
-            }
-
-            // Firebase에서 방 정보 확인 후 입장
-            FirebaseRoomManager.roomsRef.child(roomCode).get().addOnSuccessListener { snapshot ->
-                Log.d("RoomJoin", "Firebase 조회 결과 - 방 존재: ${snapshot.exists()}")
-                if (snapshot.exists()) {
-                    val room = snapshot.getValue(Room::class.java)
-                    room?.let {
-                        currentUserId?.let { userId ->
-                            // 참여자로 추가
-                            FirebaseRoomManager.addParticipant(roomCode, userId)
-                            Toast.makeText(this, "채팅방에 입장했습니다.", Toast.LENGTH_SHORT).show()
-                            binding.enterCodeOrLinkEditText.text.clear()
-                        }
-                    }
-                } else {
-                    Toast.makeText(this, "존재하지 않는 채팅방입니다.", Toast.LENGTH_SHORT).show()
-                }
-            }.addOnFailureListener { error ->
-                Log.e("RoomJoin", "Firebase 오류: ${error.message}")
-                Toast.makeText(this, "채팅방 확인에 실패했습니다.", Toast.LENGTH_SHORT).show()
-            }
-        }
-    }
-
-    private fun checkAndSaveUserInfo(userId: String, nickname: String?, email: String?) {
-        val userRef = FirebaseDatabase.getInstance().getReference("users").child(userId)
-
-        userRef.get().addOnSuccessListener { snapshot ->
-            if (!snapshot.exists()) {
-                val userMap = hashMapOf(
-                    "id" to userId,
-                    "nickname" to (nickname ?: "사용자"),
-                    "email" to (email ?: "")
-                )
-                userRef.setValue(userMap)
-                Log.d("MainActivity", "사용자 정보 저장 완료")
-            }
-        }.addOnFailureListener {
-            Log.e("MainActivity", "사용자 정보 조회 실패", it)
-        }
-    }
-
-    private fun getHashKey(context: Context) {
-        try {
-            val info = context.packageManager.getPackageInfo(
-                context.packageName,
-                PackageManager.GET_SIGNATURES
-            )
-            info.signatures?.forEach { signature ->
-                val md = MessageDigest.getInstance("SHA")
-                md.update(signature.toByteArray())
-                val hashKey = Base64.encodeToString(md.digest(), Base64.NO_WRAP)
-                Log.d("HashKey", "keyhash: $hashKey")
-            }
-        } catch (e: Exception) {
-            Log.e("HashKey", "Error: ${e.message}")
-        }
-    }
-
-    override fun onDestroy() {
-        super.onDestroy()
-        // 메모리 누수 방지를 위해 리스너 제거
-        roomsListener?.let {
-            FirebaseRoomManager.roomsRef.removeEventListener(it)
-        }
-    }
+        val adapter = ChatRoomAdapter { chatRoom ->
+            val intent = Intent(this, ChatActivity::class.java)
+            intent.putExtra("chatRoomId", chatRoom.roomId)
+            intent.putExtra("chatRoomName", chatRoom.name)
+            startActivity(intent)
+        }
 
-    override fun onResume() {
-        super.onResume()
-        // 화면 복귀 시 목록 새로고침
-        currentUserId?.let { userId ->
-            viewModel.loadRooms(userId)
-        }
+        binding.recyclerView.adapter = adapter
 
-        // 🎨 화면 복귀 시에도 버튼 색상 재설정
-        setupButtonColors()
-    }
-
-    private fun showInviteCodeDialog(room: Room) {
-        val inviteCode = room.roomCode
-
-        AlertDialog.Builder(this)
-            .setTitle("초대 코드")
-            .setMessage("\n$inviteCode")
-            .setPositiveButton("복사") { dialog, _ ->
-                val clipboard = getSystemService(Context.CLIPBOARD_SERVICE) as android.content.ClipboardManager
-                val clip = android.content.ClipData.newPlainText("roomCode", inviteCode)
-                clipboard.setPrimaryClip(clip)
-                Toast.makeText(this, "초대 코드가 복사되었습니다!", Toast.LENGTH_SHORT).show()
-                dialog.dismiss()
-            }
-            .setNegativeButton("닫기", null)
-            .show()
+        lifecycleScope.launch {
+            viewModel.chatRooms.collectLatest { chatRooms ->
+                adapter.submitList(chatRooms)
+            }
+        }
     }
-
 }
\ No newline at end of file
Index: app/src/main/java/com/example/andapp1/ChatActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.andapp1\n\nimport android.app.Activity\nimport android.content.BroadcastReceiver\nimport android.content.ContentValues\nimport android.content.Intent\nimport android.content.IntentFilter\nimport android.content.pm.PackageManager\nimport android.graphics.Bitmap\nimport android.graphics.ImageDecoder\nimport android.net.Uri\nimport android.os.*\nimport android.provider.MediaStore\nimport android.text.InputType\nimport android.util.Log\nimport android.view.*\nimport android.widget.EditText\nimport android.widget.FrameLayout\nimport android.widget.Toast\nimport android.widget.ImageView\nimport androidx.activity.result.contract.ActivityResultContracts\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.appcompat.app.AlertDialog\nimport androidx.core.app.ActivityCompat\nimport androidx.core.content.ContextCompat\nimport androidx.core.content.FileProvider\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.lifecycleScope\nimport androidx.recyclerview.widget.LinearLayoutManager\nimport com.example.andapp1.databinding.ActivityChatBinding\nimport com.example.andapp1.ocr.ReceiptOcrProcessor\nimport com.google.android.material.floatingactionbutton.FloatingActionButton\nimport com.google.firebase.database.FirebaseDatabase\nimport com.google.firebase.storage.FirebaseStorage\nimport com.stfalcon.chatkit.messages.*\nimport kotlinx.coroutines.launch\nimport java.io.File\nimport android.Manifest\nimport android.content.Context\nimport android.R.attr.bitmap\nimport android.R.attr.data\nimport android.R.id.message\nimport android.content.ClipData\nimport android.graphics.BitmapFactory\nimport android.widget.TextView\nimport com.bumptech.glide.Glide\nimport com.example.andapp1.DialogHelper.showParticipantsDialog\nimport com.stfalcon.chatkit.commons.ImageLoader\nimport org.opencv.android.OpenCVLoader\nimport java.util.Date\nimport androidx.lifecycle.Observer\nimport android.text.Spannable\nimport android.text.SpannableString\nimport android.text.method.LinkMovementMethod\nimport android.text.style.ClickableSpan\nimport android.text.util.Linkify\nimport android.view.LayoutInflater\nimport android.view.Gravity\nimport java.util.regex.Pattern\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport androidx.core.view.ViewCompat\nimport androidx.core.view.WindowInsetsCompat\n\n\nclass ChatActivity : AppCompatActivity() {\n\n    private lateinit var binding: ActivityChatBinding\n    private lateinit var viewModel: ChatViewModel\n    private lateinit var layoutManager: LinearLayoutManager\n    private lateinit var adapter: MessagesListAdapter<ChatMessage>\n    private var lastMapUrl: String? = null\n    private var cameraImageUri: Uri? = null\n    private var photoSendUri: Uri? = null\n    private var currentUser: UserEntity? = null\n    private lateinit var photoUri: Uri\n    private lateinit var senderId: String\n    private val imageMessages = mutableListOf<String>()\n    private var messagesObserver: Observer<List<ChatMessage>>? = null\n    private var lastMessageId: String? = null\n    private var shownMessageIds = mutableSetOf<String>()\n    \n    // OCR 결과 브로드캐스트 리시버\n    private val ocrMessageReceiver = object : BroadcastReceiver() {\n        override fun onReceive(context: android.content.Context?, intent: Intent?) {\n            Log.d(\"OCR_RECEIVER\", \"브로드캐스트 수신됨 - action: ${intent?.action}\")\n            \n            if (intent?.action == \"com.example.andapp1.SEND_CHAT_MESSAGE\") {\n                val message = intent.getStringExtra(\"message\")\n                val chatId = intent.getStringExtra(\"chatId\")\n                val source = intent.getStringExtra(\"source\")\n                val currentRoomCode = viewModel.roomCode\n                \n                Log.d(\"OCR_RECEIVER\", \"브로드캐스트 상세 정보:\")\n                Log.d(\"OCR_RECEIVER\", \"  - 수신 chatId: '$chatId'\")\n                Log.d(\"OCR_RECEIVER\", \"  - 현재 roomCode: '$currentRoomCode'\")\n                Log.d(\"OCR_RECEIVER\", \"  - source: '$source'\")\n                Log.d(\"OCR_RECEIVER\", \"  - message 길이: ${message?.length ?: 0}\")\n                \n                // 채팅방 매칭 조건 (더 유연하게 처리)\n                val isTargetChatRoom = when {\n                    // 1. 정확히 일치하는 경우\n                    chatId == currentRoomCode -> {\n                        Log.d(\"OCR_RECEIVER\", \"✅ chatId와 roomCode 정확히 일치\")\n                        true\n                    }\n                    // 2. chatId가 null인 경우 (현재 활성화된 채팅방으로 간주)\n                    chatId.isNullOrBlank() -> {\n                        Log.d(\"OCR_RECEIVER\", \"✅ chatId가 null/빈값 - 현재 채팅방으로 처리\")\n                        true\n                    }\n                    // 3. 기타 경우\n                    else -> {\n                        Log.d(\"OCR_RECEIVER\", \"❌ 채팅방 불일치\")\n                        false\n                    }\n                }\n                \n                Log.d(\"OCR_RECEIVER\", \"  - chatId 비교 결과: $isTargetChatRoom\")\n                \n                // 조건 확인 후 메시지 전송\n                if (message != null && isTargetChatRoom && source == \"ocr\") {\n                    Log.d(\"OCR_RECEIVER\", \"✅ 모든 조건 만족 - OCR 메시지 전송 시작\")\n                    sendChatMessage(message)\n                    \n                    Toast.makeText(this@ChatActivity, \"\uD83D\uDCB0 영수증 정산 결과가 전송되었습니다\", Toast.LENGTH_SHORT).show()\n                } else {\n                    Log.w(\"OCR_RECEIVER\", \"❌ 조건 불만족 - 메시지 전송 안함\")\n                    Log.w(\"OCR_RECEIVER\", \"  - message null? ${message == null}\")\n                    Log.w(\"OCR_RECEIVER\", \"  - target chat? $isTargetChatRoom\")\n                    Log.w(\"OCR_RECEIVER\", \"  - source ocr? ${source == \"ocr\"}\")\n                }\n            } else {\n                Log.d(\"OCR_RECEIVER\", \"다른 액션의 브로드캐스트: ${intent?.action}\")\n            }\n        }\n    }\n\n    private fun openCamera() {\n        // \uD83D\uDCCC 먼저 필요한 권한 목록\n        val permissions = mutableListOf(\n            Manifest.permission.CAMERA,\n            Manifest.permission.READ_MEDIA_IMAGES\n        )\n\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {\n            permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)\n        }\n\n        // 권한 미허용 항목 추출\n        val denied = permissions.filter {\n            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED\n        }\n\n        if (denied.isNotEmpty()) {\n            // 권한 요청\n            ActivityCompat.requestPermissions(this, denied.toTypedArray(), 1011)\n            return // ⚠\uFE0F 아직 권한 없으니까 여기서 중단\n        }\n\n        // 여기부터는 권한이 모두 허용된 상태\n        val contentValues = ContentValues().apply {\n            put(MediaStore.Images.Media.DISPLAY_NAME, \"photo_${System.currentTimeMillis()}.jpg\")\n            put(MediaStore.Images.Media.MIME_TYPE, \"image/jpeg\")\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + \"/ChatPhotos\")\n            }\n        }\n\n        photoSendUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)\n\n        if (photoSendUri == null) {\n            Log.e(\"PHOTO\", \"❌ photoSendUri 생성 실패\")\n            return\n        }\n\n        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {\n            putExtra(MediaStore.EXTRA_OUTPUT, photoSendUri)\n            addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION or Intent.FLAG_GRANT_READ_URI_PERMISSION)\n        }\n\n        photoSendLauncher.launch(intent)\n    }\n\n    override fun onRequestPermissionsResult(\n        requestCode: Int,\n        permissions: Array<out String>,\n        grantResults: IntArray\n    ) {\n        super.onRequestPermissionsResult(requestCode, permissions, grantResults)\n\n        when (requestCode) {\n            1011 -> {\n                if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {\n                    openCamera() // 권한 허용되면 다시 openCamera 실행\n                } else {\n                    Toast.makeText(this, \"사진 촬영을 위해 권한이 필요합니다.\", Toast.LENGTH_SHORT).show()\n                }\n            }\n            1010 -> {\n                Log.d(\"OCR_PERMISSIONS\", \"권한 요청 결과: ${grantResults.contentToString()}\")\n                if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {\n                    Log.d(\"OCR_PERMISSIONS\", \"모든 권한 허용됨 - 카메라 실행\")\n                    executeCameraCapture() // 권한 허용되면 바로 카메라 실행\n                } else {\n                    Log.d(\"OCR_PERMISSIONS\", \"권한 거부됨\")\n                    val deniedPermissions = permissions.filterIndexed { index, _ -> \n                        grantResults[index] != PackageManager.PERMISSION_GRANTED \n                    }\n                    Log.d(\"OCR_PERMISSIONS\", \"거부된 권한들: ${deniedPermissions.joinToString(\", \")}\")\n                    \n                    // 설정으로 이동할 수 있는 다이얼로그 표시\n                    showPermissionSettingsDialog()\n                }\n            }\n        }\n    }\n    \n    private fun openOcrCamera() {\n        Log.d(\"OCR_PERMISSIONS\", \"=== 권한 체크 시작 ===\")\n        \n        // \uD83D\uDCCC 먼저 카메라 권한 체크\n        val cameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)\n        Log.d(\"OCR_PERMISSIONS\", \"카메라 권한: ${if (cameraPermission == PackageManager.PERMISSION_GRANTED) \"허용됨\" else \"거부됨\"}\")\n        \n        // \uD83D\uDCCC Android 버전별 이미지 권한 체크 (더 강력한 검사)\n        val hasImagePermission = when {\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {\n                // Android 13+ : READ_MEDIA_IMAGES 사용\n                val mediaImagesPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES)\n                Log.d(\"OCR_PERMISSIONS\", \"READ_MEDIA_IMAGES 권한: ${if (mediaImagesPermission == PackageManager.PERMISSION_GRANTED) \"허용됨\" else \"거부됨\"}\")\n                \n                // 추가: MediaStore에 실제 접근 가능한지 테스트\n                val canAccessMediaStore = try {\n                    val cursor = contentResolver.query(\n                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,\n                        arrayOf(MediaStore.Images.Media._ID),\n                        null,\n                        null,\n                        \"${MediaStore.Images.Media.DATE_ADDED} DESC LIMIT 1\"\n                    )\n                    val canAccess = cursor != null\n                    cursor?.close()\n                    Log.d(\"OCR_PERMISSIONS\", \"MediaStore 접근 테스트: ${if (canAccess) \"성공\" else \"실패\"}\")\n                    canAccess\n                } catch (e: SecurityException) {\n                    Log.d(\"OCR_PERMISSIONS\", \"MediaStore 접근 테스트: SecurityException - ${e.message}\")\n                    false\n                } catch (e: Exception) {\n                    Log.d(\"OCR_PERMISSIONS\", \"MediaStore 접근 테스트: Exception - ${e.message}\")\n                    false\n                }\n                \n                mediaImagesPermission == PackageManager.PERMISSION_GRANTED && canAccessMediaStore\n            }\n            else -> {\n                // Android 12 이하 : READ_EXTERNAL_STORAGE 사용\n                val storagePermission = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)\n                Log.d(\"OCR_PERMISSIONS\", \"READ_EXTERNAL_STORAGE 권한: ${if (storagePermission == PackageManager.PERMISSION_GRANTED) \"허용됨\" else \"거부됨\"}\")\n                storagePermission == PackageManager.PERMISSION_GRANTED\n            }\n        }\n        \n        // \uD83D\uDCCC 권한 체크 결과\n        if (cameraPermission != PackageManager.PERMISSION_GRANTED || !hasImagePermission) {\n            Log.d(\"OCR_PERMISSIONS\", \"권한 부족 - 요청 필요\")\n            Log.d(\"OCR_PERMISSIONS\", \"카메라: ${cameraPermission == PackageManager.PERMISSION_GRANTED}, 이미지: $hasImagePermission\")\n            \n            // \uD83D\uDD27 임시 해결책: 사용자에게 강제 실행 옵션 제공\n            AlertDialog.Builder(this)\n                .setTitle(\"⚠\uFE0F 권한 문제 감지\")\n                .setMessage(\"권한이 허용되어 있음에도 불구하고 접근에 문제가 있습니다.\\n\\n\" +\n                        \"• 설정에서 권한을 다시 확인하거나\\n\" +\n                        \"• 강제로 카메라를 실행해보세요.\")\n                .setPositiveButton(\"강제 실행\") { _, _ ->\n                    Log.d(\"OCR_PERMISSIONS\", \"사용자가 강제 실행 선택\")\n                    executeCameraCapture()\n                }\n                .setNegativeButton(\"권한 설정\") { _, _ ->\n                    requestOcrPermissions()\n                }\n                .setNeutralButton(\"앱 설정 열기\") { _, _ ->\n                    showPermissionSettingsDialog()\n                }\n                .show()\n            return\n        }\n        \n        Log.d(\"OCR_PERMISSIONS\", \"모든 권한 허용됨 - 카메라 실행\")\n        executeCameraCapture()\n    }\n    \n    private fun requestOcrPermissions() {\n        val permissions = mutableListOf<String>()\n        \n        // 카메라 권한\n        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {\n            permissions.add(Manifest.permission.CAMERA)\n        }\n        \n        // Android 버전별 이미지 권한\n        when {\n            Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {\n                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) != PackageManager.PERMISSION_GRANTED) {\n                    permissions.add(Manifest.permission.READ_MEDIA_IMAGES)\n                }\n            }\n            else -> {\n                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {\n                    permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)\n                }\n            }\n        }\n        \n        Log.d(\"OCR_PERMISSIONS\", \"요청할 권한들: ${permissions.joinToString(\", \")}\")\n        \n        if (permissions.isNotEmpty()) {\n            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), 1010)\n        } else {\n            // 모든 권한이 허용된 상태\n            executeCameraCapture()\n        }\n    }\n    \n    private fun executeCameraCapture() {\n        val contentValues = ContentValues().apply {\n            put(MediaStore.Images.Media.DISPLAY_NAME, \"receipt_${System.currentTimeMillis()}.jpg\")\n            put(MediaStore.Images.Media.MIME_TYPE, \"image/jpeg\")\n            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {\n                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + \"/Receipts\")\n            }\n        }\n\n        cameraImageUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)\n\n        if (cameraImageUri == null) {\n            Log.e(\"OCR_CAMERA\", \"❌ URI 생성 실패\")\n            return\n        }\n\n        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {\n            putExtra(MediaStore.EXTRA_OUTPUT, cameraImageUri)\n            addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION or Intent.FLAG_GRANT_READ_URI_PERMISSION)\n        }\n\n        cameraIntentLauncher.launch(intent)\n    }\n    \n    private fun showPermissionSettingsDialog() {\n        AlertDialog.Builder(this)\n            .setTitle(\"\uD83D\uDD12 권한 필요\")\n            .setMessage(\"영수증 인식을 위해 다음 권한이 필요합니다:\\n\\n\" +\n                    \"• \uD83D\uDCF8 카메라: 영수증 촬영\\n\" +\n                    \"• \uD83D\uDDBC\uFE0F 사진/미디어: 이미지 저장 및 읽기\\n\\n\" +\n                    \"설정으로 이동하여 권한을 허용해주세요.\")\n            .setPositiveButton(\"설정 열기\") { _, _ ->\n                try {\n                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {\n                        data = android.net.Uri.fromParts(\"package\", packageName, null)\n                    }\n                    startActivity(intent)\n                } catch (e: Exception) {\n                    Toast.makeText(this, \"설정 화면을 열 수 없습니다.\", Toast.LENGTH_SHORT).show()\n                }\n            }\n            .setNegativeButton(\"취소\") { dialog, _ ->\n                dialog.dismiss()\n            }\n            .setCancelable(false)\n            .show()\n    }\n\n    private fun openGallery() {\n        val intent = Intent(Intent.ACTION_GET_CONTENT)\n        intent.type = \"image/*\"\n        intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)\n        startActivityForResult(intent, REQUEST_GALLERY)\n    }\n\n    private val receiptImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->\n        if (uri == null) return@registerForActivityResult\n        try {\n            // InputStream 방식이 더 안전함\n            val inputStream = contentResolver.openInputStream(uri)\n            val bitmap = inputStream?.use { BitmapFactory.decodeStream(it) }\n            if (bitmap == null) {\n                Toast.makeText(this, \"이미지 파일을 읽을 수 없습니다.\", Toast.LENGTH_SHORT).show()\n                return@registerForActivityResult\n            }\n            // \uD83D\uDCCC 카메라에서 찍은 사진과 똑같은 로직 사용\n            processOcrWithPeopleInput(bitmap)\n        } catch (e: Exception) {\n            e.printStackTrace()\n            Toast.makeText(this, \"이미지 분석에 실패했습니다: ${e.message}\", Toast.LENGTH_LONG).show()\n        }\n    }\n\n    //카메라 촬영 후 처리\n    private val cameraIntentLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->\n        if (result.resultCode == RESULT_OK && cameraImageUri != null) {\n            try {\n                // delay를 줘서 이미지 저장이 완료된 후 읽도록\n                Handler(Looper.getMainLooper()).postDelayed({\n                    val inputStream = contentResolver.openInputStream(cameraImageUri!!)\n                    val bitmap = BitmapFactory.decodeStream(inputStream)\n                    inputStream?.close()\n\n                    if (bitmap != null) {\n                        processOcrWithPeopleInput(bitmap)\n                    } else {\n                        Log.e(\"OCR_CAMERA\", \"❌ 비트맵 디코딩 실패: bitmap == null\")\n                    }\n                }, 500) // 0.5초 후 시도 (필요 시 늘릴 것)\n            } catch (e: Exception) {\n                Log.e(\"OCR_CAMERA\", \"❌ 이미지 디코딩 중 오류 발생: ${e.message}\")\n            }\n        } else {\n            Log.e(\"OCR_CAMERA\", \"❌ 사진 촬영 실패 또는 취소됨\")\n        }\n    }\n\n    private val photoSendLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->\n        if (result.resultCode == RESULT_OK && photoSendUri != null) {\n            Log.d(\"PHOTO\", \"\uD83D\uDCF7 촬영 성공 → 이미지 URI = $photoSendUri\")\n            uploadImageToFirebase(photoSendUri!!)\n        } else {\n            Log.e(\"PHOTO\", \"❌ 사진 촬영 실패 또는 URI 없음\")\n        }\n    }\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        // 상단바 겹침 문제 해결을 위한 Window 설정\n        window.statusBarColor = ContextCompat.getColor(this, R.color.colorPrimaryDark)\n        \n        if (!OpenCVLoader.initDebug()) {\n            Log.e(\"OpenCV\", \"OpenCV initialization failed\")\n        } else {\n            Log.d(\"OpenCV\", \"OpenCV initialized successfully\")\n        }\n        binding = ActivityChatBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n\n        handleSharedMapLink(intent)\n\n        val roomCode = intent.getStringExtra(\"roomCode\") ?: \"default_room\"\n        val roomName = intent.getStringExtra(\"roomName\") ?: \"채팅방\"\n        setSupportActionBar(binding.toolbar)\n        supportActionBar?.title = roomName\n        \n        // 동적 시스템 바 여백 조정 (각 기기마다 다른 상단바 높이 대응)\n        setupDynamicSystemBarInsets()\n\n        viewModel = ViewModelProvider(this, ChatViewModelFactory(roomCode, applicationContext))[ChatViewModel::class.java]\n\n        layoutManager = LinearLayoutManager(this).apply {\n            stackFromEnd = true // 가장 아래부터 시작\n            reverseLayout = false // 최신 메시지를 아래쪽에 표시\n        }\n        Log.d(\"정렬확인\", \"reverseLayout = ${layoutManager.reverseLayout}, stackFromEnd = ${layoutManager.stackFromEnd}\")\n        binding.messagesList.layoutManager = layoutManager\n        \n        // OCR 브로드캐스트 리시버 등록\n        val filter = IntentFilter(\"com.example.andapp1.SEND_CHAT_MESSAGE\")\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {\n            registerReceiver(ocrMessageReceiver, filter, Context.RECEIVER_NOT_EXPORTED)\n        } else {\n            registerReceiver(ocrMessageReceiver, filter)\n        }\n        \n        initializeAdapterAndListeners()\n    }\n    \n    /**\n     * 동적 시스템 바 여백 조정\n     * 각 기기마다 다른 상단바 높이를 자동으로 감지해서 적절한 여백 적용\n     */\n    private fun setupDynamicSystemBarInsets() {\n        Log.d(\"SystemBarInsets\", \"동적 시스템 바 여백 조정 시작\")\n        \n        // 상태바를 투명하게 하고 콘텐츠가 상태바 아래로 확장되도록 설정 (최신 방식)\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {\n            window.setDecorFitsSystemWindows(false)\n        } else {\n            @Suppress(\"DEPRECATION\")\n            window.decorView.systemUiVisibility = (\n                View.SYSTEM_UI_FLAG_LAYOUT_STABLE or \n                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN\n            )\n        }\n        window.statusBarColor = android.graphics.Color.TRANSPARENT\n        \n        ViewCompat.setOnApplyWindowInsetsListener(binding.root) { _, insets ->\n            // 시스템 바 인셋 정보 가져오기\n            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())\n            val statusBarHeight = systemBars.top\n            val navigationBarHeight = systemBars.bottom\n            \n            Log.d(\"SystemBarInsets\", \"감지된 상단바 높이: ${statusBarHeight}px\")\n            Log.d(\"SystemBarInsets\", \"감지된 네비게이션바 높이: ${navigationBarHeight}px\")\n            \n            // Toolbar에 동적 마진 적용\n            val toolbarParams = binding.toolbar.layoutParams as ViewGroup.MarginLayoutParams\n            toolbarParams.topMargin = statusBarHeight\n            binding.toolbar.layoutParams = toolbarParams\n            \n            // ⭐ 하단 입력창에 네비게이션 바 높이만큼 패딩 추가\n            binding.inputBar.setPadding(\n                binding.inputBar.paddingLeft,\n                binding.inputBar.paddingTop,\n                binding.inputBar.paddingRight,\n                binding.inputBar.paddingBottom + navigationBarHeight\n            )\n            \n            Log.d(\"SystemBarInsets\", \"Toolbar 마진 조정 완료 - 상단: ${statusBarHeight}px\")\n            Log.d(\"SystemBarInsets\", \"입력창 패딩 조정 완료 - 하단: ${navigationBarHeight}px\")\n            Log.d(\"SystemBarInsets\", \"동적 시스템 바 여백 조정 완료\")\n            \n            // 원본 인셋 반환\n            insets\n        }\n    }\n\n    override fun onNewIntent(intent: Intent?) {\n        super.onNewIntent(intent)\n        Log.d(\"ChatActivity\", \"\uD83C\uDF10 onNewIntent 호출됨\")\n\n        intent?.getStringExtra(\"mapUrl\")?.let { url ->\n            Log.d(\"ChatActivity\", \"\uD83C\uDF10 받은 지도 URL: $url\")\n            lastMapUrl = url\n            showMapRestoreButton()\n        }\n        intent?.getStringExtra(\"scrapText\")?.let { sharedMapUrl ->\n            // ✅ 중복 전송 방지를 위한 검사\n            val alreadySent = intent.getBooleanExtra(\"alreadySent\", false)\n            if (!alreadySent) {\n                Log.d(\"ChatActivity\", \"\uD83D\uDCE9 공유 메시지 전송: $sharedMapUrl\")\n                viewModel.sendMapUrlMessage(sharedMapUrl)\n\n                // ✅ 재진입 시 중복 방지 위해 플래그 추가\n                intent.putExtra(\"alreadySent\", true)\n            } else {\n                Log.d(\"ChatActivity\", \"⚠ 이미 전송된 메시지라 무시\")\n            }\n        }\n    }\n\n    private fun showMapRestoreButton() {\n        val rootView = findViewById<ViewGroup>(android.R.id.content)\n\n        // 중복 방지: 이미 있는 경우 추가 X\n        val existing = rootView.findViewWithTag<FloatingActionButton>(\"map_restore_button\")\n        if (existing != null) {\n            Log.d(\"ChatActivity\", \"\uD83E\uDDED 이미 플로팅 버튼 존재 - 중복 생성 방지\")\n            return\n        }\n\n        val fab = FloatingActionButton(this).apply {\n            tag = \"map_restore_button\" // ✅ 중복 방지용 태그\n\n            setImageResource(R.drawable.ic_map)\n\n            backgroundTintList = ContextCompat.getColorStateList(context, android.R.color.white)\n            imageTintList = ContextCompat.getColorStateList(context, android.R.color.black)\n\n            layoutParams = FrameLayout.LayoutParams(\n                ViewGroup.LayoutParams.WRAP_CONTENT,\n                ViewGroup.LayoutParams.WRAP_CONTENT\n            ).apply {\n                gravity = Gravity.TOP or Gravity.END\n                marginEnd = 32\n                topMargin = 100\n            }\n\n            val dragKey = R.id.view_tag_drag_info\n\n            setOnTouchListener { view, event ->\n                when (event.action) {\n                    MotionEvent.ACTION_DOWN -> {\n                        view.setTag(dragKey, Triple(event.rawX, event.rawY, false))\n                        true\n                    }\n                    MotionEvent.ACTION_MOVE -> {\n                        val (startX, startY, _) = view.getTag(dragKey) as Triple<Float, Float, Boolean>\n                        val dx = event.rawX - startX\n                        val dy = event.rawY - startY\n                        val isDragged = dx * dx + dy * dy > 100\n                        if (isDragged) {\n                            view.x += dx\n                            view.y += dy\n                            view.setTag(dragKey, Triple(event.rawX, event.rawY, true))\n                        }\n                        true\n                    }\n                    MotionEvent.ACTION_UP -> {\n                        val (_, _, isDragged) = view.getTag(dragKey) as Triple<Float, Float, Boolean>\n                        if (!isDragged) {\n                            lastMapUrl?.let { url ->\n                                val intent = Intent(this@ChatActivity, MapActivity::class.java).apply {\n                                    putExtra(\"mapUrl\", url)\n                                    addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)\n                                }\n                                startActivity(intent)\n                            }\n\n                        }\n                        true\n                    }\n                    else -> false\n                }\n            }\n        }\n        rootView.addView(fab)\n    }\n\n    private fun handleSharedMapLink(intent: Intent?) {\n        if (intent?.action == Intent.ACTION_SEND && intent.type == \"text/plain\") {\n            val sharedText = intent.getStringExtra(Intent.EXTRA_TEXT)\n            if (!sharedText.isNullOrBlank()) {\n                Log.d(\"MapShare\", \"공유받은 지도 링크: $sharedText\")\n                sendChatMessage(\"\uD83D\uDCCD 공유된 지도 링크: $sharedText\")\n            }\n        }\n    }\n\n    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {\n        super.onActivityResult(requestCode, resultCode, data)\n\n        if (resultCode == RESULT_OK) {\n            when (requestCode) {\n                REQUEST_CAMERA -> {\n                    sendImageMessage(photoUri.toString())\n                }\n                REQUEST_GALLERY -> {\n                    // 여러 장 선택했을 때\n                    val clipData = data?.clipData\n                    if (clipData != null) {\n                        for (i in 0 until clipData.itemCount) {\n                            val imageUri = clipData.getItemAt(i).uri\n                            uploadImageToFirebase(imageUri)\n                        }\n                    } else {\n                        // 한 장만 선택한 경우\n                        val selectedImageUri = data?.data\n                        if (selectedImageUri != null) {\n                            uploadImageToFirebase(selectedImageUri)\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private fun initializeAdapterAndListeners() {\n        lifecycleScope.launch {\n            Log.d(\"ChatActivity_UserLoad\", \"사용자 정보 로드 시작\")\n            \n            // 1) DB에서 currentUser 불러오기\n            val user = try {\n                RoomDatabaseInstance\n                    .getInstance(applicationContext)\n                    .userDao()\n                    .getUser()\n            } catch (e: Exception) {\n                Log.e(\"ChatActivity_UserLoad\", \"사용자 정보 DB 조회 실패\", e)\n                null\n            }\n            \n            currentUser = user\n            \n            Log.d(\"ChatActivity_UserLoad\", \"DB 조회 결과 - user: ${user?.let { \"ID: ${it.id}, Nickname: ${it.nickname}\" } ?: \"null\"}\")\n\n            if (user == null) {\n                Log.w(\"ChatActivity_UserLoad\", \"사용자 정보가 null입니다. 로그인 상태를 확인하세요.\")\n                Toast.makeText(this@ChatActivity, \"⚠ 사용자 정보를 불러오지 못했습니다. 다시 로그인해주세요.\", Toast.LENGTH_LONG).show()\n                \n                // 로그인 화면으로 돌아가기\n                val intent = Intent(this@ChatActivity, LoginActivity::class.java)\n                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\n                startActivity(intent)\n                finish()\n                return@launch\n            }\n\n            senderId = user.id\n            Log.d(\"ChatActivity_UserLoad\", \"senderId 설정 완료: $senderId\")\n\n            // 2) Firebase 참여자 확인\n            Log.d(\"ChatActivity_Participants\", \"Firebase 참여자 확인 시작 - User: ${user.id}, Room: ${viewModel.roomCode}\")\n            \n            val participantsRef = FirebaseDatabase.getInstance()\n                .getReference(\"rooms\")\n                .child(viewModel.roomCode)\n                .child(\"participants\")\n                .child(user.id)\n\n            participantsRef.get().addOnSuccessListener { snapshot ->\n                Log.d(\"ChatActivity_Participants\", \"참가자 스냅샷 수신. key: ${snapshot.key}, exists: ${snapshot.exists()}\")\n                if (!snapshot.exists()) {\n                    Toast.makeText(this@ChatActivity, \"⚠ 이미 나간 채팅방이거나 참여자 정보 없음.\", Toast.LENGTH_SHORT).show()\n                    Log.w(\"ChatActivity_Participants\", \"참가자가 아니므로 finish() 호출됨. User ID: ${user.id}, Room Code: ${viewModel.roomCode}\")\n                    finish() // \uD83D\uDEAB 채팅방 입장 금지\n                } else {\n                    Log.d(\"ChatActivity_Participants\", \"✅ 참가자 확인 완료. User ID: ${user.id}, Room Code: ${viewModel.roomCode}\")\n                }\n            }.addOnFailureListener { exception ->\n                Log.e(\"ChatActivity_Participants\", \"참가자 정보 로드 실패: ${exception.message}\", exception)\n                Toast.makeText(this@ChatActivity, \"⚠ 참가자 정보를 가져오는데 실패했습니다.\", Toast.LENGTH_SHORT).show()\n                // 실패 시에도 일단 진행 (네트워크 문제일 수 있음)\n            }\n\n            // ✅ 커스텀 ViewHolder 사용\n            val holders = MessageHolders()\n                .setIncomingTextHolder(\n                    CustomIncomingTextViewHolder::class.java,\n                    R.layout.item_incoming_text_message\n                )\n                .setIncomingImageHolder(\n                    CustomIncomingImageViewHolder::class.java,\n                    R.layout.item_incoming_image_message\n                )\n                // outcoming은 기본 사용 (프로필 이미지 없음)\n                .setOutcomingTextHolder(\n                    TextMessageViewHolder::class.java,\n                    com.stfalcon.chatkit.R.layout.item_outcoming_text_message\n                )\n                .setOutcomingImageHolder(\n                    OutcomingImageMessageViewHolder::class.java,\n                    R.layout.item_outcoming_image_message\n                )\n\n            // 3) 어댑터 생성\n            adapter = MessagesListAdapter<ChatMessage>(\n                senderId,\n                holders,\n                ImageLoader { imageView, url, _ ->\n                    // ✅ 디버깅 로그 추가\n                    Log.d(\"ProfileDebug\", \"=== ImageLoader 호출됨 ===\")\n                    Log.d(\"ProfileDebug\", \"ImageView: $imageView\")\n                    Log.d(\"ProfileDebug\", \"URL: $url\")\n\n                    if (!url.isNullOrEmpty()) {\n                        Log.d(\"ProfileDebug\", \"Glide로 이미지 로드 시작: $url\")\n                        Glide.with(imageView.context)\n                            .load(url)\n                            .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지 표시\n                            .into(imageView)\n                    } else {\n                        Log.w(\"ProfileDebug\", \"URL이 비어있어서 기본 이미지 설정\")\n                        imageView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지\n                    }\n                }\n            )\n\n            binding.messagesList.setAdapter(adapter)\n\n            // 메시지 클릭 (텍스트 메시지용)\n            adapter.setOnMessageClickListener { message: ChatMessage ->\n                val imageUrl = message.imageUrlValue\n                Log.d(\"\uD83D\uDCA5클릭된 메시지\", \"imageUrlValue = $imageUrl\")\n\n                // \uD83D\uDCF8 이미지 메시지만 처리 (텍스트 메시지는 TextMessageViewHolder에서 처리)\n                if (!imageUrl.isNullOrEmpty()) {\n                    val urls = imageMessages\n                    val idx = urls.indexOf(imageUrl)\n\n                    val photoListToSend = if (idx != -1) {\n                        ArrayList(urls)\n                    } else {\n                        arrayListOf(imageUrl)\n                    }\n\n                    val position = if (idx != -1) idx else 0\n\n                    Log.d(\"ChatActivity\", \"▶\uFE0E 이미지 클릭 → photoList=$photoListToSend, index=$position\")\n\n                    val intent = Intent(this@ChatActivity, ImageViewerActivity::class.java)\n                        .putStringArrayListExtra(\"photoList\", photoListToSend)\n                        .putExtra(\"startPosition\", position)\n\n                    startActivity(intent)\n                }\n            }\n\n            // 텍스트 전송 버튼\n            binding.customMessageInput.setInputListener { input ->\n                viewModel.sendMessage(input.toString())\n\n                // \uD83D\uDD3D 메시지 전송 후 자동 스크롤 추가\n                binding.messagesList.post {\n                    layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)\n                }\n                true\n            }\n\n            // 사진 버튼\n            binding.btnSendPhoto.setOnClickListener {\n                val options = arrayOf(\"\uD83D\uDCF8 사진 촬영\", \"\uD83D\uDDBC\uFE0F 갤러리에서 선택\")\n                DialogHelper.showStyledChoiceDialog(\n                    context = this@ChatActivity,\n                    title = \"사진 전송 방법 선택\",\n                    options = options\n                ) { which ->\n                    if (which == 0) openCamera() else openGallery()\n                }\n            }\n            // 메시지 옵저빙 시작\n            observeMessages()\n        }\n    }\n\n    private fun observeMessages() {\n        viewModel.messages.observe(this) { messages ->\n\n\n\n            val sorted = messages\n                .filter { it.messageId.isNotBlank() }\n                .distinctBy { it.messageId }\n                .sortedBy { it.createdAt.time }\n                .reversed() // ✅ 최신이 아래로 오도록 보장\n\n\n            adapter.setItems(sorted)\n\n            imageMessages.clear()\n            imageMessages.addAll(\n                messages.filter { !it.imageUrlValue.isNullOrEmpty() }\n                    .map { it.imageUrlValue!! }\n            )\n            ChatImageStore.imageMessages = imageMessages // \uD83D\uDC48 전역 저장\n\n            binding.messagesList.post {\n                layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)\n            }\n        }\n    }\n\n    private fun scrollToBottomSmooth() {\n        binding.messagesList.postDelayed({\n            if (adapter.itemCount > 0) binding.messagesList.scrollToPosition(adapter.itemCount)\n        }, 300)\n    }\n\n    override fun onCreateOptionsMenu(menu: Menu?): Boolean {\n        // 메뉴 XML을 사용하지 않고 직접 메뉴 아이템 추가\n        menu?.add(0, 1001, 0, \"메뉴\")?.apply {\n            setIcon(R.drawable.ic_menu)\n            setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS)\n        }\n        return true\n    }\n\n    override fun onOptionsItemSelected(item: MenuItem): Boolean {\n        return when (item.itemId) {\n            1001 -> {\n                // 새로운 채팅방 메뉴 액티비티로 이동\n                val intent = Intent(this, ChatRoomMenuActivity::class.java).apply {\n                    putExtra(\"roomCode\", viewModel.roomCode)\n                    putExtra(\"roomName\", supportActionBar?.title?.toString() ?: \"채팅방\")\n                }\n                startActivity(intent)\n                true\n            }\n            android.R.id.home -> {\n                finish()\n                true\n            }\n            else -> super.onOptionsItemSelected(item)\n        }\n    }\n\n    private fun showOcrChoiceDialog() {\n        val options = arrayOf(\"\uD83D\uDCF8 사진 촬영\", \"\uD83D\uDDBC\uFE0F 갤러리에서 선택\")\n\n        DialogHelper.showStyledChoiceDialog(\n            context = this,\n            title = \"영수증 인식 방법 선택\",\n            options = options\n        ) { which ->\n            when (which) {\n                0 -> {\n                    Log.d(\"OCR_CAMERA\", \"\uD83D\uDCF8 사진 촬영 선택됨\")\n                    openOcrCamera()\n                }\n\n                1 -> {\n                    Log.d(\"OCR_CAMERA\", \"\uD83D\uDDBC\uFE0F 사진 선택 선택됨\")\n                    receiptImageLauncher.launch(\"image/*\")\n                }\n            }\n        }\n    }\n\n    private fun processOcrWithPeopleInput(bitmap: Bitmap) {\n        val participantsRef = FirebaseDatabase.getInstance()\n            .getReference(\"rooms\")\n            .child(viewModel.roomCode)\n            .child(\"participants\")\n\n        participantsRef.get().addOnSuccessListener { snapshot ->\n            val defaultPeople = snapshot.childrenCount.toInt().coerceAtLeast(1)\n            showParticipantsInputDialog(bitmap, defaultPeople)\n        }.addOnFailureListener { exception ->\n            Log.e(\"FIREBASE_OCR\", \"참여자 수 로드 실패. 기본값 사용.\", exception)\n            showParticipantsInputDialog(bitmap, 4, \"참여자 정보를 가져오지 못했습니다. 기본값(4명)을 사용합니다.\")\n        }\n    }\n\n    private fun showParticipantsInputDialog(bitmap: Bitmap, defaultPeopleCount: Int, messageHint: String? = null) {\n        val editText = EditText(this@ChatActivity).apply {\n            setText(defaultPeopleCount.toString())\n            inputType = InputType.TYPE_CLASS_NUMBER\n        }\n\n        val dialogTitle = \"정산 인원 수를 입력하세요\"\n        val dialogMessage = messageHint ?: \"정산 인원을 입력해주세요. (현재 방 인원 자동 반영: ${defaultPeopleCount}명)\"\n\n\n        AlertDialog.Builder(this@ChatActivity)\n            .setTitle(dialogTitle)\n            .setMessage(dialogMessage)\n            .setView(editText)\n            .setPositiveButton(\"확인\") { _, _ ->\n                val enteredPeople = editText.text.toString().toIntOrNull()\n                val finalValidPeople = enteredPeople?.takeIf { it > 0 } ?: defaultPeopleCount\n\n                if (enteredPeople != null && enteredPeople <= 0) {\n                    Toast.makeText(this@ChatActivity, \"정산 인원은 1명 이상이어야 합니다. 기본값(${defaultPeopleCount}명)으로 설정됩니다.\", Toast.LENGTH_LONG).show()\n                }\n\n                lifecycleScope.launch(Dispatchers.Default) {\n                    try {\n                        val ocrText = ReceiptOcrProcessor.processReceipt(this@ChatActivity, bitmap)\n                        val totalAmount = ReceiptOcrProcessor.extractTotalAmount(ocrText)\n                        \n                        if (totalAmount != null && totalAmount > 0) {\n                            val perPerson = totalAmount / finalValidPeople\n                            val message = \"\uD83D\uDCDD 영수증 정산\\n\" +\n                                        \"→ 총액: ${totalAmount}원\\n\" +\n                                        \"→ 인원: ${finalValidPeople}명\\n\" +\n                                        \"→ 1인당: ${perPerson}원\"\n                            sendChatMessage(message) \n                        } else {\n                            withContext(Dispatchers.Main) {\n                                Toast.makeText(this@ChatActivity, \"영수증 총액을 인식할 수 없습니다.\", Toast.LENGTH_SHORT).show()\n                            }\n                        }\n                    } catch (e: Exception) {\n                        Log.e(\"OCR_PROCESS\", \"ChatActivity OCR 처리 중 예외\", e)\n                        withContext(Dispatchers.Main) {\n                            Toast.makeText(this@ChatActivity, \"영수증 인식에 실패했습니다.\", Toast.LENGTH_SHORT).show()\n                        }\n                    }\n                }\n            }\n            .setNegativeButton(\"취소\", null)\n            .show()\n    }\n\n    private fun uploadImageToFirebase(uri: Uri) {\n        val fileName = \"images/${System.currentTimeMillis()}.jpg\"\n        val storageRef = FirebaseStorage.getInstance().reference.child(fileName)\n\n        Log.d(\"PHOTO\", \"업로드 시도 URI: $uri\")\n\n        storageRef.putFile(uri)\n            .addOnSuccessListener {\n                Log.d(\"PHOTO\", \"✅ 업로드 성공\")\n                storageRef.downloadUrl.addOnSuccessListener { downloadUrl ->\n                    Log.d(\"PHOTO\", \"✅ 다운로드 URL: $downloadUrl\")\n                    sendImageMessage(downloadUrl.toString()) // 이때 imageUrlValue로 넣어야 함\n                }\n            }\n            .addOnFailureListener { e ->\n                Log.e(\"PHOTO\", \"❌ 업로드 실패: ${e.message}\")\n                e.printStackTrace()\n                Toast.makeText(this, \"사진 업로드 실패\", Toast.LENGTH_SHORT).show()\n            }\n    }\n\n    private fun sendChatMessage(message: String) {\n        Log.d(\"ChatActivity\", \"\uD83D\uDCE4 OCR 메시지 전송 시작: $message\")\n        viewModel.sendMessage(message)\n        \n        // 메시지 전송 후 자동 스크롤\n        binding.messagesList.post {\n            layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)\n        }\n    }\n\n    private fun sendImageMessage(imageUrl: String) {\n        Log.d(\"ChatActivity\", \"Sending image message: $imageUrl\")\n\n        val user = currentUser ?: return\n        val author = Author(\n            user.id,\n            user.nickname ?: \"알 수 없음\",\n            user.profileImageUrl // ✅ 프로필 이미지 URL 설정\n        )\n\n        val message = ChatMessage(\n            messageId = \"\",\n            text = \"\",\n            user = author,\n            imageUrlValue = imageUrl,\n            createdAt = Date()\n        )\n\n        Log.d(\"\uD83D\uDD0D ChatDebug\", \"adapter senderId = $senderId\")\n        Log.d(\"\uD83D\uDD0D ChatDebug\", \"message sender id = ${message.getUser().getId()}\")\n\n        viewModel.sendMessage(message)\n    }\n\n    override fun onDestroy() {\n        super.onDestroy()\n        \n        // OCR 브로드캐스트 리시버 해제\n        try {\n            unregisterReceiver(ocrMessageReceiver)\n            Log.d(\"ChatActivity_Lifecycle\", \"OCR 브로드캐스트 리시버 해제 완료\")\n        } catch (e: Exception) {\n            Log.w(\"ChatActivity_Lifecycle\", \"OCR 브로드캐스트 리시버 해제 실패: ${e.message}\")\n        }\n        \n        Log.d(\"ChatActivity_Lifecycle\", \"onDestroy 호출됨\", Exception(\"onDestroy Call Stack\"))\n    }\n\n    companion object {\n        const val REQUEST_CAMERA = 1001\n        const val REQUEST_GALLERY = 1002\n    }\n}\nclass CustomIncomingTextViewHolder(itemView: View) : MessageHolders.IncomingTextMessageViewHolder<ChatMessage>(itemView) {\n\n    override fun onBind(message: ChatMessage) {\n        super.onBind(message)\n\n        val messageTextView = itemView.findViewById<TextView>(R.id.messageText)\n        val rawText = message.text\n        val spannable = SpannableString(rawText)\n\n        Linkify.addLinks(spannable, Linkify.WEB_URLS)\n        processMapUrls(spannable, rawText)\n\n        messageTextView.text = spannable\n        messageTextView.movementMethod = LinkMovementMethod.getInstance()\n        messageTextView.linksClickable = true\n\n        messageTextView.setOnTouchListener { v, event ->\n            val textView = v as TextView\n            val s = textView.text as? Spannable ?: return@setOnTouchListener false\n\n            val action = event.action\n            if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {\n                val x = event.x.toInt() - textView.totalPaddingLeft + textView.scrollX\n                val y = event.y.toInt() - textView.totalPaddingTop + textView.scrollY\n\n                val layout = textView.layout ?: return@setOnTouchListener false\n                val line = layout.getLineForVertical(y)\n                val off = layout.getOffsetForHorizontal(line, x.toFloat())\n\n                val links = s.getSpans(off, off, ClickableSpan::class.java)\n                if (links.isNotEmpty()) {\n                    if (action == MotionEvent.ACTION_UP) {\n                        links[0].onClick(textView)\n                    }\n                    return@setOnTouchListener true\n                }\n            }\n            return@setOnTouchListener false\n        }\n        // 프로필 이미지 설정\n        val avatarView = itemView.findViewById<ImageView>(R.id.messageUserAvatar)\n        val avatarUrl = message.getUser().getAvatar()\n\n        Log.d(\"CustomViewHolder\", \"텍스트 메시지 프로필 이미지 로드: $avatarUrl\")\n\n        if (!avatarUrl.isNullOrEmpty()) {\n            Glide.with(itemView.context)\n                .load(avatarUrl)\n                .circleCrop() // 원형으로 표시\n                .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지\n                .into(avatarView)\n        } else {\n            avatarView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지\n        }\n\n        // ✅ 사용자 이름 설정\n        val userNameView = itemView.findViewById<TextView>(R.id.messageUserName)\n        val userName = message.getUser().getName()\n        userNameView.text = if (userName.isNotEmpty()) userName else \"알 수 없음\"\n\n        Log.d(\"CustomViewHolder\", \"사용자 이름 설정: $userName\")\n\n        // ✅ 프로필 이미지 클릭 이벤트 추가 (사용자 상세 보기)\n        avatarView.setOnClickListener {\n            showUserDetailDialog(itemView.context, message.getUser())\n        }\n\n        // ✅ 사용자 이름 클릭 이벤트 추가\n        userNameView.setOnClickListener {\n            showUserDetailDialog(itemView.context, message.getUser())\n        }\n    }\n\n    private fun processMapUrls(spannable: Spannable, text: String) {\n        // 지도 URL 패턴\n        val mapPatterns = arrayOf(\n            \"https://m\\\\.map\\\\.naver\\\\.com[^\\\\s]*\",\n            \"https://map\\\\.naver\\\\.com[^\\\\s]*\",\n            \"https://map\\\\.kakao\\\\.com[^\\\\s]*\",\n            \"https://maps\\\\.google\\\\.com[^\\\\s]*\",\n            \"https://www\\\\.google\\\\.com/maps[^\\\\s]*\"\n        )\n\n        for (patternStr in mapPatterns) {\n            val pattern = Pattern.compile(patternStr, Pattern.CASE_INSENSITIVE)\n            val matcher = pattern.matcher(text)\n\n            while (matcher.find()) {\n                val start = matcher.start()\n                val end = matcher.end()\n                val mapUrl = text.substring(start, end)\n\n                Log.d(\"TextMessageViewHolder\", \"\uD83D\uDDFA\uFE0F 지도 URL 발견: $mapUrl\")\n\n                // 기존 URL 링크 제거하고 커스텀 링크로 교체\n                val existingSpans = spannable.getSpans(start, end, ClickableSpan::class.java)\n                for (span in existingSpans) {\n                    spannable.removeSpan(span)\n                }\n\n                // 커스텀 지도 링크 적용\n                val mapClickSpan = object : ClickableSpan() {\n                    override fun onClick(widget: View) {\n                        Log.d(\"TextMessageViewHolder\", \"\uD83D\uDDFA\uFE0F 지도 링크 클릭: $mapUrl\")\n                        try {\n                            val intent = Intent(widget.context, MapActivity::class.java)\n                            intent.putExtra(\"mapUrl\", mapUrl)\n                            widget.context.startActivity(intent)\n                        } catch (e: Exception) {\n                            Log.e(\"TextMessageViewHolder\", \"지도 액티비티 실행 실패\", e)\n                        }\n                    }\n                }\n\n                spannable.setSpan(\n                    mapClickSpan,\n                    start,\n                    end,\n                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE\n                )\n            }\n        }\n    }\n\n    private fun showUserDetailDialog(context: Context, user: com.stfalcon.chatkit.commons.models.IUser) {\n        // ✅ 커스텀 레이아웃 생성\n        val dialogView = LayoutInflater.from(context).inflate(android.R.layout.select_dialog_item, null)\n\n        // LinearLayout을 수동으로 생성하여 이미지와 텍스트를 표시\n        val linearLayout = android.widget.LinearLayout(context).apply {\n            orientation = android.widget.LinearLayout.VERTICAL\n            setPadding(40, 40, 40, 40)\n        }\n\n        // 프로필 이미지 추가\n        val profileImageView = ImageView(context).apply {\n            layoutParams = android.widget.LinearLayout.LayoutParams(300, 300).apply {\n                gravity = Gravity.CENTER_HORIZONTAL\n                bottomMargin = 20\n            }\n            scaleType = ImageView.ScaleType.CENTER_CROP\n            // 둥근 모서리 배경 설정\n            background = ContextCompat.getDrawable(context, android.R.drawable.dialog_frame)\n        }\n\n        // 사용자 정보 텍스트 (ID 제거)\n        val userInfoText = TextView(context).apply {\n            text = \"${user.getName()}\"\n            textSize = 18f\n            gravity = Gravity.CENTER\n            setPadding(0, 20, 0, 0)\n            setTypeface(null, android.graphics.Typeface.BOLD)\n        }\n\n        // 레이아웃에 뷰들 추가\n        linearLayout.addView(profileImageView)\n        linearLayout.addView(userInfoText)\n\n        // 이미지 로드\n        if (!user.getAvatar().isNullOrEmpty()) {\n            Log.d(\"UserDialog\", \"프로필 이미지 로드: ${user.getAvatar()}\")\n            Glide.with(context)\n                .load(user.getAvatar())\n                .centerCrop()\n                .error(R.drawable.ic_launcher_background)\n                .into(profileImageView)\n        } else {\n            profileImageView.setImageResource(R.drawable.ic_launcher_background)\n        }\n\n        // 다이얼로그 생성\n        val dialog = AlertDialog.Builder(context)\n            .setTitle(\"\uD83D\uDC64 사용자 정보\")\n            .setView(linearLayout)\n            .setPositiveButton(\"확인\", null)\n            .setNeutralButton(\"프로필 크게 보기\") { _, _ ->\n                // 프로필 이미지를 전체화면으로 보기\n                showFullScreenImage(context, user.getAvatar())\n            }\n            .create()\n\n        dialog.show()\n    }\n\n    private fun showFullScreenImage(context: Context, imageUrl: String?) {\n        if (imageUrl.isNullOrEmpty()) {\n            Toast.makeText(context, \"프로필 이미지가 없습니다.\", Toast.LENGTH_SHORT).show()\n            return\n        }\n\n        // 전체화면 이미지 뷰어를 위한 간단한 액티비티 호출\n        // 또는 ImageViewerActivity 재활용\n        val intent = Intent(context, ImageViewerActivity::class.java).apply {\n            putStringArrayListExtra(\"photoList\", arrayListOf(imageUrl))\n            putExtra(\"startPosition\", 0)\n        }\n        context.startActivity(intent)\n    }\n}\n\nclass CustomIncomingImageViewHolder(itemView: View) : MessageHolders.IncomingImageMessageViewHolder<ChatMessage>(itemView) {\n\n    override fun onBind(message: ChatMessage) {\n        super.onBind(message)\n\n        // 프로필 이미지 설정\n        val avatarView = itemView.findViewById<ImageView>(R.id.messageUserAvatar)\n        val avatarUrl = message.getUser().getAvatar()\n\n        Log.d(\"CustomViewHolder\", \"이미지 메시지 프로필 이미지 로드: $avatarUrl\")\n\n        if (!avatarUrl.isNullOrEmpty()) {\n            Glide.with(itemView.context)\n                .load(avatarUrl)\n                .circleCrop() // 원형으로 표시\n                .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지\n                .into(avatarView)\n        } else {\n            avatarView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지\n        }\n\n        // ✅ 사용자 이름 설정\n        val userNameView = itemView.findViewById<TextView>(R.id.messageUserName)\n        val userName = message.getUser().getName()\n        userNameView.text = if (userName.isNotEmpty()) userName else \"알 수 없음\"\n\n        Log.d(\"CustomViewHolder\", \"사용자 이름 설정: $userName\")\n\n        // ✅ 프로필 이미지 클릭 이벤트 추가 (사용자 상세 보기)\n        avatarView.setOnClickListener {\n            showUserDetailDialog(itemView.context, message.getUser())\n        }\n\n        // ✅ 사용자 이름 클릭 이벤트 추가\n        userNameView.setOnClickListener {\n            showUserDetailDialog(itemView.context, message.getUser())\n        }\n\n        // ✅ 기존 이미지 클릭 기능 유지 (이미지 확대 보기)\n        val imageView = itemView.findViewById<ImageView>(R.id.image)\n        imageView.setOnClickListener {\n            val url = message.imageUrlValue ?: return@setOnClickListener\n            val allImages = ChatImageStore.imageMessages\n            val idx = allImages.indexOf(url)\n            val photoList = if (idx != -1) ArrayList(allImages) else arrayListOf(url)\n            val position = if (idx != -1) idx else 0\n\n            val intent = Intent(itemView.context, ImageViewerActivity::class.java).apply {\n                putStringArrayListExtra(\"photoList\", photoList)\n                putExtra(\"startPosition\", position)\n            }\n\n            itemView.context.startActivity(intent)\n        }\n    }\n\n    private fun showUserDetailDialog(context: Context, user: com.stfalcon.chatkit.commons.models.IUser) {\n        // ✅ 커스텀 레이아웃 생성\n        val linearLayout = android.widget.LinearLayout(context).apply {\n            orientation = android.widget.LinearLayout.VERTICAL\n            setPadding(40, 40, 40, 40)\n        }\n\n        // 프로필 이미지 추가\n        val profileImageView = ImageView(context).apply {\n            layoutParams = android.widget.LinearLayout.LayoutParams(300, 300).apply {\n                gravity = Gravity.CENTER_HORIZONTAL\n                bottomMargin = 20\n            }\n            scaleType = ImageView.ScaleType.CENTER_CROP\n            // 둥근 모서리 배경 설정\n            background = ContextCompat.getDrawable(context, android.R.drawable.dialog_frame)\n        }\n\n        // 사용자 정보 텍스트 (ID 제거)\n        val userInfoText = TextView(context).apply {\n            text = \"${user.getName()}\"\n            textSize = 18f\n            gravity = Gravity.CENTER\n            setPadding(0, 20, 0, 0)\n            setTypeface(null, android.graphics.Typeface.BOLD)\n        }\n\n        // 레이아웃에 뷰들 추가\n        linearLayout.addView(profileImageView)\n        linearLayout.addView(userInfoText)\n\n        // 이미지 로드\n        if (!user.getAvatar().isNullOrEmpty()) {\n            Log.d(\"UserDialog\", \"프로필 이미지 로드: ${user.getAvatar()}\")\n            Glide.with(context)\n                .load(user.getAvatar())\n                .centerCrop()\n                .error(R.drawable.ic_launcher_background)\n                .into(profileImageView)\n        } else {\n            profileImageView.setImageResource(R.drawable.ic_launcher_background)\n        }\n\n        // 다이얼로그 생성\n        val dialog = AlertDialog.Builder(context)\n            .setTitle(\"\uD83D\uDC64 사용자 정보\")\n            .setView(linearLayout)\n            .setPositiveButton(\"확인\", null)\n            .setNeutralButton(\"프로필 크게 보기\") { _, _ ->\n                // 프로필 이미지를 전체화면으로 보기\n                showFullScreenImage(context, user.getAvatar())\n            }\n            .create()\n\n        dialog.show()\n    }\n\n    private fun showFullScreenImage(context: Context, imageUrl: String?) {\n        if (imageUrl.isNullOrEmpty()) {\n            Toast.makeText(context, \"프로필 이미지가 없습니다.\", Toast.LENGTH_SHORT).show()\n            return\n        }\n\n        // 전체화면 이미지 뷰어를 위한 간단한 액티비티 호출\n        // 또는 ImageViewerActivity 재활용\n        val intent = Intent(context, ImageViewerActivity::class.java).apply {\n            putStringArrayListExtra(\"photoList\", arrayListOf(imageUrl))\n            putExtra(\"startPosition\", 0)\n        }\n        context.startActivity(intent)\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/ChatActivity.kt b/app/src/main/java/com/example/andapp1/ChatActivity.kt
--- a/app/src/main/java/com/example/andapp1/ChatActivity.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/ChatActivity.kt	(date 1749652095680)
@@ -1,1363 +1,228 @@
 package com.example.andapp1
 
+import android.Manifest
 import android.app.Activity
-import android.content.BroadcastReceiver
 import android.content.ContentValues
 import android.content.Intent
-import android.content.IntentFilter
 import android.content.pm.PackageManager
-import android.graphics.Bitmap
-import android.graphics.ImageDecoder
 import android.net.Uri
-import android.os.*
+import android.os.Bundle
 import android.provider.MediaStore
-import android.text.InputType
 import android.util.Log
-import android.view.*
-import android.widget.EditText
-import android.widget.FrameLayout
-import android.widget.Toast
+import android.view.Menu
+import android.view.MenuItem
 import android.widget.ImageView
+import android.widget.Toast
 import androidx.activity.result.contract.ActivityResultContracts
+import androidx.activity.viewModels
 import androidx.appcompat.app.AppCompatActivity
-import androidx.appcompat.app.AlertDialog
 import androidx.core.app.ActivityCompat
 import androidx.core.content.ContextCompat
-import androidx.core.content.FileProvider
-import androidx.lifecycle.ViewModelProvider
 import androidx.lifecycle.lifecycleScope
-import androidx.recyclerview.widget.LinearLayoutManager
-import com.example.andapp1.databinding.ActivityChatBinding
-import com.example.andapp1.ocr.ReceiptOcrProcessor
-import com.google.android.material.floatingactionbutton.FloatingActionButton
-import com.google.firebase.database.FirebaseDatabase
-import com.google.firebase.storage.FirebaseStorage
-import com.stfalcon.chatkit.messages.*
-import kotlinx.coroutines.launch
-import java.io.File
-import android.Manifest
-import android.content.Context
-import android.R.attr.bitmap
-import android.R.attr.data
-import android.R.id.message
-import android.content.ClipData
-import android.graphics.BitmapFactory
-import android.widget.TextView
 import com.bumptech.glide.Glide
-import com.example.andapp1.DialogHelper.showParticipantsDialog
+import com.example.andapp1.databinding.ActivityChatBinding
+import com.example.andapp1.ocr.OcrActivity
+import com.google.firebase.auth.FirebaseAuth
 import com.stfalcon.chatkit.commons.ImageLoader
+import com.stfalcon.chatkit.messages.MessageInput
+import com.stfalcon.chatkit.messages.MessagesListAdapter
+import dagger.hilt.android.AndroidEntryPoint
+import kotlinx.coroutines.flow.collectLatest
+import kotlinx.coroutines.launch
 import org.opencv.android.OpenCVLoader
-import java.util.Date
-import androidx.lifecycle.Observer
-import android.text.Spannable
-import android.text.SpannableString
-import android.text.method.LinkMovementMethod
-import android.text.style.ClickableSpan
-import android.text.util.Linkify
-import android.view.LayoutInflater
-import android.view.Gravity
-import java.util.regex.Pattern
-import kotlinx.coroutines.Dispatchers
-import kotlinx.coroutines.withContext
-import androidx.core.view.ViewCompat
-import androidx.core.view.WindowInsetsCompat
 
-
-class ChatActivity : AppCompatActivity() {
+@AndroidEntryPoint
+class ChatActivity : AppCompatActivity(), MessageInput.InputListener,
+    MessageInput.AttachmentsListener {
 
     private lateinit var binding: ActivityChatBinding
-    private lateinit var viewModel: ChatViewModel
-    private lateinit var layoutManager: LinearLayoutManager
-    private lateinit var adapter: MessagesListAdapter<ChatMessage>
-    private var lastMapUrl: String? = null
-    private var cameraImageUri: Uri? = null
-    private var photoSendUri: Uri? = null
-    private var currentUser: UserEntity? = null
-    private lateinit var photoUri: Uri
-    private lateinit var senderId: String
-    private val imageMessages = mutableListOf<String>()
-    private var messagesObserver: Observer<List<ChatMessage>>? = null
-    private var lastMessageId: String? = null
-    private var shownMessageIds = mutableSetOf<String>()
-    
-    // OCR 결과 브로드캐스트 리시버
-    private val ocrMessageReceiver = object : BroadcastReceiver() {
-        override fun onReceive(context: android.content.Context?, intent: Intent?) {
-            Log.d("OCR_RECEIVER", "브로드캐스트 수신됨 - action: ${intent?.action}")
-            
-            if (intent?.action == "com.example.andapp1.SEND_CHAT_MESSAGE") {
-                val message = intent.getStringExtra("message")
-                val chatId = intent.getStringExtra("chatId")
-                val source = intent.getStringExtra("source")
-                val currentRoomCode = viewModel.roomCode
-                
-                Log.d("OCR_RECEIVER", "브로드캐스트 상세 정보:")
-                Log.d("OCR_RECEIVER", "  - 수신 chatId: '$chatId'")
-                Log.d("OCR_RECEIVER", "  - 현재 roomCode: '$currentRoomCode'")
-                Log.d("OCR_RECEIVER", "  - source: '$source'")
-                Log.d("OCR_RECEIVER", "  - message 길이: ${message?.length ?: 0}")
-                
-                // 채팅방 매칭 조건 (더 유연하게 처리)
-                val isTargetChatRoom = when {
-                    // 1. 정확히 일치하는 경우
-                    chatId == currentRoomCode -> {
-                        Log.d("OCR_RECEIVER", "✅ chatId와 roomCode 정확히 일치")
-                        true
-                    }
-                    // 2. chatId가 null인 경우 (현재 활성화된 채팅방으로 간주)
-                    chatId.isNullOrBlank() -> {
-                        Log.d("OCR_RECEIVER", "✅ chatId가 null/빈값 - 현재 채팅방으로 처리")
-                        true
-                    }
-                    // 3. 기타 경우
-                    else -> {
-                        Log.d("OCR_RECEIVER", "❌ 채팅방 불일치")
-                        false
-                    }
-                }
-                
-                Log.d("OCR_RECEIVER", "  - chatId 비교 결과: $isTargetChatRoom")
-                
-                // 조건 확인 후 메시지 전송
-                if (message != null && isTargetChatRoom && source == "ocr") {
-                    Log.d("OCR_RECEIVER", "✅ 모든 조건 만족 - OCR 메시지 전송 시작")
-                    sendChatMessage(message)
-                    
-                    Toast.makeText(this@ChatActivity, "💰 영수증 정산 결과가 전송되었습니다", Toast.LENGTH_SHORT).show()
-                } else {
-                    Log.w("OCR_RECEIVER", "❌ 조건 불만족 - 메시지 전송 안함")
-                    Log.w("OCR_RECEIVER", "  - message null? ${message == null}")
-                    Log.w("OCR_RECEIVER", "  - target chat? $isTargetChatRoom")
-                    Log.w("OCR_RECEIVER", "  - source ocr? ${source == "ocr"}")
-                }
-            } else {
-                Log.d("OCR_RECEIVER", "다른 액션의 브로드캐스트: ${intent?.action}")
-            }
-        }
-    }
-
-    private fun openCamera() {
-        // 📌 먼저 필요한 권한 목록
-        val permissions = mutableListOf(
-            Manifest.permission.CAMERA,
-            Manifest.permission.READ_MEDIA_IMAGES
-        )
-
-        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.TIRAMISU) {
-            permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
-        }
+    private val viewModel: ChatViewModel by viewModels()
+    private lateinit var messagesAdapter: MessagesListAdapter<Message>
 
-        // 권한 미허용 항목 추출
-        val denied = permissions.filter {
-            ContextCompat.checkSelfPermission(this, it) != PackageManager.PERMISSION_GRANTED
-        }
+    private val myUid = FirebaseAuth.getInstance().currentUser?.uid ?: ""
+    private var chatRoomId: String? = null
 
-        if (denied.isNotEmpty()) {
-            // 권한 요청
-            ActivityCompat.requestPermissions(this, denied.toTypedArray(), 1011)
-            return // ⚠️ 아직 권한 없으니까 여기서 중단
-        }
+    private var photoUri: Uri? = null
 
-        // 여기부터는 권한이 모두 허용된 상태
-        val contentValues = ContentValues().apply {
-            put(MediaStore.Images.Media.DISPLAY_NAME, "photo_${System.currentTimeMillis()}.jpg")
-            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
-                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/ChatPhotos")
-            }
-        }
-
-        photoSendUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
-
-        if (photoSendUri == null) {
-            Log.e("PHOTO", "❌ photoSendUri 생성 실패")
-            return
+    private val photoLauncher =
+        registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
+            if (result.resultCode == Activity.RESULT_OK) {
+                photoUri?.let {
+                    viewModel.sendImageMessage(it)
+                    Log.d("ChatActivity", "Image sent via ViewModel")
+                }
+            }
         }
-
-        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {
-            putExtra(MediaStore.EXTRA_OUTPUT, photoSendUri)
-            addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION or Intent.FLAG_GRANT_READ_URI_PERMISSION)
-        }
 
-        photoSendLauncher.launch(intent)
-    }
-
-    override fun onRequestPermissionsResult(
-        requestCode: Int,
-        permissions: Array<out String>,
-        grantResults: IntArray
-    ) {
-        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
-
-        when (requestCode) {
-            1011 -> {
-                if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
-                    openCamera() // 권한 허용되면 다시 openCamera 실행
-                } else {
-                    Toast.makeText(this, "사진 촬영을 위해 권한이 필요합니다.", Toast.LENGTH_SHORT).show()
-                }
-            }
-            1010 -> {
-                Log.d("OCR_PERMISSIONS", "권한 요청 결과: ${grantResults.contentToString()}")
-                if (grantResults.all { it == PackageManager.PERMISSION_GRANTED }) {
-                    Log.d("OCR_PERMISSIONS", "모든 권한 허용됨 - 카메라 실행")
-                    executeCameraCapture() // 권한 허용되면 바로 카메라 실행
-                } else {
-                    Log.d("OCR_PERMISSIONS", "권한 거부됨")
-                    val deniedPermissions = permissions.filterIndexed { index, _ -> 
-                        grantResults[index] != PackageManager.PERMISSION_GRANTED 
-                    }
-                    Log.d("OCR_PERMISSIONS", "거부된 권한들: ${deniedPermissions.joinToString(", ")}")
-                    
-                    // 설정으로 이동할 수 있는 다이얼로그 표시
-                    showPermissionSettingsDialog()
-                }
-            }
-        }
-    }
-    
-    private fun openOcrCamera() {
-        Log.d("OCR_PERMISSIONS", "=== 권한 체크 시작 ===")
-        
-        // 📌 먼저 카메라 권한 체크
-        val cameraPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA)
-        Log.d("OCR_PERMISSIONS", "카메라 권한: ${if (cameraPermission == PackageManager.PERMISSION_GRANTED) "허용됨" else "거부됨"}")
-        
-        // 📌 Android 버전별 이미지 권한 체크 (더 강력한 검사)
-        val hasImagePermission = when {
-            Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
-                // Android 13+ : READ_MEDIA_IMAGES 사용
-                val mediaImagesPermission = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES)
-                Log.d("OCR_PERMISSIONS", "READ_MEDIA_IMAGES 권한: ${if (mediaImagesPermission == PackageManager.PERMISSION_GRANTED) "허용됨" else "거부됨"}")
-                
-                // 추가: MediaStore에 실제 접근 가능한지 테스트
-                val canAccessMediaStore = try {
-                    val cursor = contentResolver.query(
-                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
-                        arrayOf(MediaStore.Images.Media._ID),
-                        null,
-                        null,
-                        "${MediaStore.Images.Media.DATE_ADDED} DESC LIMIT 1"
-                    )
-                    val canAccess = cursor != null
-                    cursor?.close()
-                    Log.d("OCR_PERMISSIONS", "MediaStore 접근 테스트: ${if (canAccess) "성공" else "실패"}")
-                    canAccess
-                } catch (e: SecurityException) {
-                    Log.d("OCR_PERMISSIONS", "MediaStore 접근 테스트: SecurityException - ${e.message}")
-                    false
-                } catch (e: Exception) {
-                    Log.d("OCR_PERMISSIONS", "MediaStore 접근 테스트: Exception - ${e.message}")
-                    false
-                }
-                
-                mediaImagesPermission == PackageManager.PERMISSION_GRANTED && canAccessMediaStore
-            }
-            else -> {
-                // Android 12 이하 : READ_EXTERNAL_STORAGE 사용
-                val storagePermission = ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE)
-                Log.d("OCR_PERMISSIONS", "READ_EXTERNAL_STORAGE 권한: ${if (storagePermission == PackageManager.PERMISSION_GRANTED) "허용됨" else "거부됨"}")
-                storagePermission == PackageManager.PERMISSION_GRANTED
-            }
-        }
-        
-        // 📌 권한 체크 결과
-        if (cameraPermission != PackageManager.PERMISSION_GRANTED || !hasImagePermission) {
-            Log.d("OCR_PERMISSIONS", "권한 부족 - 요청 필요")
-            Log.d("OCR_PERMISSIONS", "카메라: ${cameraPermission == PackageManager.PERMISSION_GRANTED}, 이미지: $hasImagePermission")
-            
-            // 🔧 임시 해결책: 사용자에게 강제 실행 옵션 제공
-            AlertDialog.Builder(this)
-                .setTitle("⚠️ 권한 문제 감지")
-                .setMessage("권한이 허용되어 있음에도 불구하고 접근에 문제가 있습니다.\n\n" +
-                        "• 설정에서 권한을 다시 확인하거나\n" +
-                        "• 강제로 카메라를 실행해보세요.")
-                .setPositiveButton("강제 실행") { _, _ ->
-                    Log.d("OCR_PERMISSIONS", "사용자가 강제 실행 선택")
-                    executeCameraCapture()
-                }
-                .setNegativeButton("권한 설정") { _, _ ->
-                    requestOcrPermissions()
-                }
-                .setNeutralButton("앱 설정 열기") { _, _ ->
-                    showPermissionSettingsDialog()
-                }
-                .show()
-            return
-        }
-        
-        Log.d("OCR_PERMISSIONS", "모든 권한 허용됨 - 카메라 실행")
-        executeCameraCapture()
-    }
-    
-    private fun requestOcrPermissions() {
-        val permissions = mutableListOf<String>()
-        
-        // 카메라 권한
-        if (ContextCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
-            permissions.add(Manifest.permission.CAMERA)
-        }
-        
-        // Android 버전별 이미지 권한
-        when {
-            Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU -> {
-                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_MEDIA_IMAGES) != PackageManager.PERMISSION_GRANTED) {
-                    permissions.add(Manifest.permission.READ_MEDIA_IMAGES)
-                }
-            }
-            else -> {
-                if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
-                    permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE)
-                }
-            }
-        }
-        
-        Log.d("OCR_PERMISSIONS", "요청할 권한들: ${permissions.joinToString(", ")}")
-        
-        if (permissions.isNotEmpty()) {
-            ActivityCompat.requestPermissions(this, permissions.toTypedArray(), 1010)
-        } else {
-            // 모든 권한이 허용된 상태
-            executeCameraCapture()
-        }
-    }
-    
-    private fun executeCameraCapture() {
-        val contentValues = ContentValues().apply {
-            put(MediaStore.Images.Media.DISPLAY_NAME, "receipt_${System.currentTimeMillis()}.jpg")
-            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
-                put(MediaStore.Images.Media.RELATIVE_PATH, Environment.DIRECTORY_PICTURES + "/Receipts")
-            }
-        }
-
-        cameraImageUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, contentValues)
-
-        if (cameraImageUri == null) {
-            Log.e("OCR_CAMERA", "❌ URI 생성 실패")
-            return
-        }
-
-        val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {
-            putExtra(MediaStore.EXTRA_OUTPUT, cameraImageUri)
-            addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION or Intent.FLAG_GRANT_READ_URI_PERMISSION)
-        }
-
-        cameraIntentLauncher.launch(intent)
-    }
-    
-    private fun showPermissionSettingsDialog() {
-        AlertDialog.Builder(this)
-            .setTitle("🔒 권한 필요")
-            .setMessage("영수증 인식을 위해 다음 권한이 필요합니다:\n\n" +
-                    "• 📸 카메라: 영수증 촬영\n" +
-                    "• 🖼️ 사진/미디어: 이미지 저장 및 읽기\n\n" +
-                    "설정으로 이동하여 권한을 허용해주세요.")
-            .setPositiveButton("설정 열기") { _, _ ->
-                try {
-                    val intent = Intent(android.provider.Settings.ACTION_APPLICATION_DETAILS_SETTINGS).apply {
-                        data = android.net.Uri.fromParts("package", packageName, null)
-                    }
-                    startActivity(intent)
-                } catch (e: Exception) {
-                    Toast.makeText(this, "설정 화면을 열 수 없습니다.", Toast.LENGTH_SHORT).show()
-                }
-            }
-            .setNegativeButton("취소") { dialog, _ ->
-                dialog.dismiss()
-            }
-            .setCancelable(false)
-            .show()
-    }
-
-    private fun openGallery() {
-        val intent = Intent(Intent.ACTION_GET_CONTENT)
-        intent.type = "image/*"
-        intent.putExtra(Intent.EXTRA_ALLOW_MULTIPLE, true)
-        startActivityForResult(intent, REQUEST_GALLERY)
-    }
-
-    private val receiptImageLauncher = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
-        if (uri == null) return@registerForActivityResult
-        try {
-            // InputStream 방식이 더 안전함
-            val inputStream = contentResolver.openInputStream(uri)
-            val bitmap = inputStream?.use { BitmapFactory.decodeStream(it) }
-            if (bitmap == null) {
-                Toast.makeText(this, "이미지 파일을 읽을 수 없습니다.", Toast.LENGTH_SHORT).show()
-                return@registerForActivityResult
-            }
-            // 📌 카메라에서 찍은 사진과 똑같은 로직 사용
-            processOcrWithPeopleInput(bitmap)
-        } catch (e: Exception) {
-            e.printStackTrace()
-            Toast.makeText(this, "이미지 분석에 실패했습니다: ${e.message}", Toast.LENGTH_LONG).show()
-        }
-    }
-
-    //카메라 촬영 후 처리
-    private val cameraIntentLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
-        if (result.resultCode == RESULT_OK && cameraImageUri != null) {
-            try {
-                // delay를 줘서 이미지 저장이 완료된 후 읽도록
-                Handler(Looper.getMainLooper()).postDelayed({
-                    val inputStream = contentResolver.openInputStream(cameraImageUri!!)
-                    val bitmap = BitmapFactory.decodeStream(inputStream)
-                    inputStream?.close()
-
-                    if (bitmap != null) {
-                        processOcrWithPeopleInput(bitmap)
-                    } else {
-                        Log.e("OCR_CAMERA", "❌ 비트맵 디코딩 실패: bitmap == null")
-                    }
-                }, 500) // 0.5초 후 시도 (필요 시 늘릴 것)
-            } catch (e: Exception) {
-                Log.e("OCR_CAMERA", "❌ 이미지 디코딩 중 오류 발생: ${e.message}")
-            }
-        } else {
-            Log.e("OCR_CAMERA", "❌ 사진 촬영 실패 또는 취소됨")
-        }
-    }
-
-    private val photoSendLauncher = registerForActivityResult(ActivityResultContracts.StartActivityForResult()) { result ->
-        if (result.resultCode == RESULT_OK && photoSendUri != null) {
-            Log.d("PHOTO", "📷 촬영 성공 → 이미지 URI = $photoSendUri")
-            uploadImageToFirebase(photoSendUri!!)
-        } else {
-            Log.e("PHOTO", "❌ 사진 촬영 실패 또는 URI 없음")
+    private val getContent = registerForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
+        uri?.let {
+            chatRoomId?.let { roomId ->
+                viewModel.uploadImage(roomId, it)
+            }
         }
     }
 
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
-
-        // 상단바 겹침 문제 해결을 위한 Window 설정
-        window.statusBarColor = ContextCompat.getColor(this, R.color.colorPrimaryDark)
-        
-        if (!OpenCVLoader.initDebug()) {
-            Log.e("OpenCV", "OpenCV initialization failed")
-        } else {
-            Log.d("OpenCV", "OpenCV initialized successfully")
-        }
         binding = ActivityChatBinding.inflate(layoutInflater)
         setContentView(binding.root)
 
-        handleSharedMapLink(intent)
+        initOpenCV()
+        setupToolbar()
 
-        val roomCode = intent.getStringExtra("roomCode") ?: "default_room"
-        val roomName = intent.getStringExtra("roomName") ?: "채팅방"
-        setSupportActionBar(binding.toolbar)
-        supportActionBar?.title = roomName
-        
-        // 동적 시스템 바 여백 조정 (각 기기마다 다른 상단바 높이 대응)
-        setupDynamicSystemBarInsets()
-
-        viewModel = ViewModelProvider(this, ChatViewModelFactory(roomCode, applicationContext))[ChatViewModel::class.java]
-
-        layoutManager = LinearLayoutManager(this).apply {
-            stackFromEnd = true // 가장 아래부터 시작
-            reverseLayout = false // 최신 메시지를 아래쪽에 표시
-        }
-        Log.d("정렬확인", "reverseLayout = ${layoutManager.reverseLayout}, stackFromEnd = ${layoutManager.stackFromEnd}")
-        binding.messagesList.layoutManager = layoutManager
-        
-        // OCR 브로드캐스트 리시버 등록
-        val filter = IntentFilter("com.example.andapp1.SEND_CHAT_MESSAGE")
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
-            registerReceiver(ocrMessageReceiver, filter, Context.RECEIVER_NOT_EXPORTED)
-        } else {
-            registerReceiver(ocrMessageReceiver, filter)
-        }
-        
-        initializeAdapterAndListeners()
-    }
-    
-    /**
-     * 동적 시스템 바 여백 조정
-     * 각 기기마다 다른 상단바 높이를 자동으로 감지해서 적절한 여백 적용
-     */
-    private fun setupDynamicSystemBarInsets() {
-        Log.d("SystemBarInsets", "동적 시스템 바 여백 조정 시작")
-        
-        // 상태바를 투명하게 하고 콘텐츠가 상태바 아래로 확장되도록 설정 (최신 방식)
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.R) {
-            window.setDecorFitsSystemWindows(false)
-        } else {
-            @Suppress("DEPRECATION")
-            window.decorView.systemUiVisibility = (
-                View.SYSTEM_UI_FLAG_LAYOUT_STABLE or 
-                View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-            )
-        }
-        window.statusBarColor = android.graphics.Color.TRANSPARENT
-        
-        ViewCompat.setOnApplyWindowInsetsListener(binding.root) { _, insets ->
-            // 시스템 바 인셋 정보 가져오기
-            val systemBars = insets.getInsets(WindowInsetsCompat.Type.systemBars())
-            val statusBarHeight = systemBars.top
-            val navigationBarHeight = systemBars.bottom
-            
-            Log.d("SystemBarInsets", "감지된 상단바 높이: ${statusBarHeight}px")
-            Log.d("SystemBarInsets", "감지된 네비게이션바 높이: ${navigationBarHeight}px")
-            
-            // Toolbar에 동적 마진 적용
-            val toolbarParams = binding.toolbar.layoutParams as ViewGroup.MarginLayoutParams
-            toolbarParams.topMargin = statusBarHeight
-            binding.toolbar.layoutParams = toolbarParams
-            
-            // ⭐ 하단 입력창에 네비게이션 바 높이만큼 패딩 추가
-            binding.inputBar.setPadding(
-                binding.inputBar.paddingLeft,
-                binding.inputBar.paddingTop,
-                binding.inputBar.paddingRight,
-                binding.inputBar.paddingBottom + navigationBarHeight
-            )
-            
-            Log.d("SystemBarInsets", "Toolbar 마진 조정 완료 - 상단: ${statusBarHeight}px")
-            Log.d("SystemBarInsets", "입력창 패딩 조정 완료 - 하단: ${navigationBarHeight}px")
-            Log.d("SystemBarInsets", "동적 시스템 바 여백 조정 완료")
-            
-            // 원본 인셋 반환
-            insets
-        }
-    }
-
-    override fun onNewIntent(intent: Intent?) {
-        super.onNewIntent(intent)
-        Log.d("ChatActivity", "🌐 onNewIntent 호출됨")
-
-        intent?.getStringExtra("mapUrl")?.let { url ->
-            Log.d("ChatActivity", "🌐 받은 지도 URL: $url")
-            lastMapUrl = url
-            showMapRestoreButton()
-        }
-        intent?.getStringExtra("scrapText")?.let { sharedMapUrl ->
-            // ✅ 중복 전송 방지를 위한 검사
-            val alreadySent = intent.getBooleanExtra("alreadySent", false)
-            if (!alreadySent) {
-                Log.d("ChatActivity", "📩 공유 메시지 전송: $sharedMapUrl")
-                viewModel.sendMapUrlMessage(sharedMapUrl)
-
-                // ✅ 재진입 시 중복 방지 위해 플래그 추가
-                intent.putExtra("alreadySent", true)
-            } else {
-                Log.d("ChatActivity", "⚠ 이미 전송된 메시지라 무시")
-            }
-        }
-    }
-
-    private fun showMapRestoreButton() {
-        val rootView = findViewById<ViewGroup>(android.R.id.content)
-
-        // 중복 방지: 이미 있는 경우 추가 X
-        val existing = rootView.findViewWithTag<FloatingActionButton>("map_restore_button")
-        if (existing != null) {
-            Log.d("ChatActivity", "🧭 이미 플로팅 버튼 존재 - 중복 생성 방지")
+        chatRoomId = intent.getStringExtra("chatRoomId")
+        val chatRoomName = intent.getStringExtra("chatRoomName")
+        binding.toolbar.title = chatRoomName
+
+        if (chatRoomId == null) {
+            Toast.makeText(this, "Failed to load chat room.", Toast.LENGTH_SHORT).show()
+            finish()
             return
         }
 
-        val fab = FloatingActionButton(this).apply {
-            tag = "map_restore_button" // ✅ 중복 방지용 태그
-
-            setImageResource(R.drawable.ic_map)
-
-            backgroundTintList = ContextCompat.getColorStateList(context, android.R.color.white)
-            imageTintList = ContextCompat.getColorStateList(context, android.R.color.black)
-
-            layoutParams = FrameLayout.LayoutParams(
-                ViewGroup.LayoutParams.WRAP_CONTENT,
-                ViewGroup.LayoutParams.WRAP_CONTENT
-            ).apply {
-                gravity = Gravity.TOP or Gravity.END
-                marginEnd = 32
-                topMargin = 100
-            }
-
-            val dragKey = R.id.view_tag_drag_info
-
-            setOnTouchListener { view, event ->
-                when (event.action) {
-                    MotionEvent.ACTION_DOWN -> {
-                        view.setTag(dragKey, Triple(event.rawX, event.rawY, false))
-                        true
-                    }
-                    MotionEvent.ACTION_MOVE -> {
-                        val (startX, startY, _) = view.getTag(dragKey) as Triple<Float, Float, Boolean>
-                        val dx = event.rawX - startX
-                        val dy = event.rawY - startY
-                        val isDragged = dx * dx + dy * dy > 100
-                        if (isDragged) {
-                            view.x += dx
-                            view.y += dy
-                            view.setTag(dragKey, Triple(event.rawX, event.rawY, true))
-                        }
-                        true
-                    }
-                    MotionEvent.ACTION_UP -> {
-                        val (_, _, isDragged) = view.getTag(dragKey) as Triple<Float, Float, Boolean>
-                        if (!isDragged) {
-                            lastMapUrl?.let { url ->
-                                val intent = Intent(this@ChatActivity, MapActivity::class.java).apply {
-                                    putExtra("mapUrl", url)
-                                    addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)
-                                }
-                                startActivity(intent)
-                            }
-
-                        }
-                        true
-                    }
-                    else -> false
-                }
-            }
-        }
-        rootView.addView(fab)
-    }
-
-    private fun handleSharedMapLink(intent: Intent?) {
-        if (intent?.action == Intent.ACTION_SEND && intent.type == "text/plain") {
-            val sharedText = intent.getStringExtra(Intent.EXTRA_TEXT)
-            if (!sharedText.isNullOrBlank()) {
-                Log.d("MapShare", "공유받은 지도 링크: $sharedText")
-                sendChatMessage("📍 공유된 지도 링크: $sharedText")
-            }
-        }
-    }
+        setupMessagesAdapter()
+        binding.input.setInputListener(this)
+        binding.input.setAttachmentsListener(this)
 
-    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
-        super.onActivityResult(requestCode, resultCode, data)
+        chatRoomId?.let { viewModel.loadMessages(it) }
 
-        if (resultCode == RESULT_OK) {
-            when (requestCode) {
-                REQUEST_CAMERA -> {
-                    sendImageMessage(photoUri.toString())
-                }
-                REQUEST_GALLERY -> {
-                    // 여러 장 선택했을 때
-                    val clipData = data?.clipData
-                    if (clipData != null) {
-                        for (i in 0 until clipData.itemCount) {
-                            val imageUri = clipData.getItemAt(i).uri
-                            uploadImageToFirebase(imageUri)
-                        }
-                    } else {
-                        // 한 장만 선택한 경우
-                        val selectedImageUri = data?.data
-                        if (selectedImageUri != null) {
-                            uploadImageToFirebase(selectedImageUri)
-                        }
-                    }
-                }
-            }
-        }
-    }
-
-    private fun initializeAdapterAndListeners() {
         lifecycleScope.launch {
-            Log.d("ChatActivity_UserLoad", "사용자 정보 로드 시작")
-            
-            // 1) DB에서 currentUser 불러오기
-            val user = try {
-                RoomDatabaseInstance
-                    .getInstance(applicationContext)
-                    .userDao()
-                    .getUser()
-            } catch (e: Exception) {
-                Log.e("ChatActivity_UserLoad", "사용자 정보 DB 조회 실패", e)
-                null
+            viewModel.messages.collectLatest { messages ->
+                messagesAdapter.clear()
+                messagesAdapter.addToEnd(messages, false)
             }
-            
-            currentUser = user
-            
-            Log.d("ChatActivity_UserLoad", "DB 조회 결과 - user: ${user?.let { "ID: ${it.id}, Nickname: ${it.nickname}" } ?: "null"}")
-
-            if (user == null) {
-                Log.w("ChatActivity_UserLoad", "사용자 정보가 null입니다. 로그인 상태를 확인하세요.")
-                Toast.makeText(this@ChatActivity, "⚠ 사용자 정보를 불러오지 못했습니다. 다시 로그인해주세요.", Toast.LENGTH_LONG).show()
-                
-                // 로그인 화면으로 돌아가기
-                val intent = Intent(this@ChatActivity, LoginActivity::class.java)
-                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK
-                startActivity(intent)
-                finish()
-                return@launch
-            }
+        }
 
-            senderId = user.id
-            Log.d("ChatActivity_UserLoad", "senderId 설정 완료: $senderId")
-
-            // 2) Firebase 참여자 확인
-            Log.d("ChatActivity_Participants", "Firebase 참여자 확인 시작 - User: ${user.id}, Room: ${viewModel.roomCode}")
-            
-            val participantsRef = FirebaseDatabase.getInstance()
-                .getReference("rooms")
-                .child(viewModel.roomCode)
-                .child("participants")
-                .child(user.id)
-
-            participantsRef.get().addOnSuccessListener { snapshot ->
-                Log.d("ChatActivity_Participants", "참가자 스냅샷 수신. key: ${snapshot.key}, exists: ${snapshot.exists()}")
-                if (!snapshot.exists()) {
-                    Toast.makeText(this@ChatActivity, "⚠ 이미 나간 채팅방이거나 참여자 정보 없음.", Toast.LENGTH_SHORT).show()
-                    Log.w("ChatActivity_Participants", "참가자가 아니므로 finish() 호출됨. User ID: ${user.id}, Room Code: ${viewModel.roomCode}")
-                    finish() // 🚫 채팅방 입장 금지
-                } else {
-                    Log.d("ChatActivity_Participants", "✅ 참가자 확인 완료. User ID: ${user.id}, Room Code: ${viewModel.roomCode}")
+        lifecycleScope.launch {
+            viewModel.imageUploadResult.collectLatest { result ->
+                result?.onSuccess {
+                    Toast.makeText(this@ChatActivity, "Image sent!", Toast.LENGTH_SHORT).show()
+                }?.onFailure {
+                    Toast.makeText(this@ChatActivity, "Image upload failed", Toast.LENGTH_SHORT).show()
                 }
-            }.addOnFailureListener { exception ->
-                Log.e("ChatActivity_Participants", "참가자 정보 로드 실패: ${exception.message}", exception)
-                Toast.makeText(this@ChatActivity, "⚠ 참가자 정보를 가져오는데 실패했습니다.", Toast.LENGTH_SHORT).show()
-                // 실패 시에도 일단 진행 (네트워크 문제일 수 있음)
             }
-
-            // ✅ 커스텀 ViewHolder 사용
-            val holders = MessageHolders()
-                .setIncomingTextHolder(
-                    CustomIncomingTextViewHolder::class.java,
-                    R.layout.item_incoming_text_message
-                )
-                .setIncomingImageHolder(
-                    CustomIncomingImageViewHolder::class.java,
-                    R.layout.item_incoming_image_message
-                )
-                // outcoming은 기본 사용 (프로필 이미지 없음)
-                .setOutcomingTextHolder(
-                    TextMessageViewHolder::class.java,
-                    com.stfalcon.chatkit.R.layout.item_outcoming_text_message
-                )
-                .setOutcomingImageHolder(
-                    OutcomingImageMessageViewHolder::class.java,
-                    R.layout.item_outcoming_image_message
-                )
-
-            // 3) 어댑터 생성
-            adapter = MessagesListAdapter<ChatMessage>(
-                senderId,
-                holders,
-                ImageLoader { imageView, url, _ ->
-                    // ✅ 디버깅 로그 추가
-                    Log.d("ProfileDebug", "=== ImageLoader 호출됨 ===")
-                    Log.d("ProfileDebug", "ImageView: $imageView")
-                    Log.d("ProfileDebug", "URL: $url")
-
-                    if (!url.isNullOrEmpty()) {
-                        Log.d("ProfileDebug", "Glide로 이미지 로드 시작: $url")
-                        Glide.with(imageView.context)
-                            .load(url)
-                            .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지 표시
-                            .into(imageView)
-                    } else {
-                        Log.w("ProfileDebug", "URL이 비어있어서 기본 이미지 설정")
-                        imageView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지
-                    }
-                }
-            )
-
-            binding.messagesList.setAdapter(adapter)
-
-            // 메시지 클릭 (텍스트 메시지용)
-            adapter.setOnMessageClickListener { message: ChatMessage ->
-                val imageUrl = message.imageUrlValue
-                Log.d("💥클릭된 메시지", "imageUrlValue = $imageUrl")
-
-                // 📸 이미지 메시지만 처리 (텍스트 메시지는 TextMessageViewHolder에서 처리)
-                if (!imageUrl.isNullOrEmpty()) {
-                    val urls = imageMessages
-                    val idx = urls.indexOf(imageUrl)
+        }
 
-                    val photoListToSend = if (idx != -1) {
-                        ArrayList(urls)
-                    } else {
-                        arrayListOf(imageUrl)
-                    }
+        handleSharedText()
+    }
 
-                    val position = if (idx != -1) idx else 0
-
-                    Log.d("ChatActivity", "▶︎ 이미지 클릭 → photoList=$photoListToSend, index=$position")
-
-                    val intent = Intent(this@ChatActivity, ImageViewerActivity::class.java)
-                        .putStringArrayListExtra("photoList", photoListToSend)
-                        .putExtra("startPosition", position)
-
-                    startActivity(intent)
-                }
+    private fun setupMessagesAdapter() {
+        val imageLoader = ImageLoader { imageView: ImageView?, url: String?, _: Any? ->
+            imageView?.let {
+                Glide.with(this).load(url).into(it)
             }
-
-            // 텍스트 전송 버튼
-            binding.customMessageInput.setInputListener { input ->
-                viewModel.sendMessage(input.toString())
-
-                // 🔽 메시지 전송 후 자동 스크롤 추가
-                binding.messagesList.post {
-                    layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)
-                }
-                true
-            }
+        }
+        messagesAdapter = MessagesListAdapter(myUid, imageLoader)
+        binding.messagesList.setAdapter(messagesAdapter)
+    }
 
-            // 사진 버튼
-            binding.btnSendPhoto.setOnClickListener {
-                val options = arrayOf("📸 사진 촬영", "🖼️ 갤러리에서 선택")
-                DialogHelper.showStyledChoiceDialog(
-                    context = this@ChatActivity,
-                    title = "사진 전송 방법 선택",
-                    options = options
-                ) { which ->
-                    if (which == 0) openCamera() else openGallery()
-                }
-            }
-            // 메시지 옵저빙 시작
-            observeMessages()
-        }
+    private fun setupUI() {
+        binding.input.setInputListener(this)
+        binding.input.setAttachmentsListener(this)
     }
 
-    private fun observeMessages() {
-        viewModel.messages.observe(this) { messages ->
-
-
-
-            val sorted = messages
-                .filter { it.messageId.isNotBlank() }
-                .distinctBy { it.messageId }
-                .sortedBy { it.createdAt.time }
-                .reversed() // ✅ 최신이 아래로 오도록 보장
-
-
-            adapter.setItems(sorted)
-
-            imageMessages.clear()
-            imageMessages.addAll(
-                messages.filter { !it.imageUrlValue.isNullOrEmpty() }
-                    .map { it.imageUrlValue!! }
-            )
-            ChatImageStore.imageMessages = imageMessages // 👈 전역 저장
-
-            binding.messagesList.post {
-                layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)
-            }
+    override fun onSubmit(input: CharSequence?): Boolean {
+        if (chatRoomId != null && !input.isNullOrBlank()) {
+            viewModel.sendMessage(chatRoomId!!, input.toString(), myUid)
+            return true
         }
+        return false
     }
 
-    private fun scrollToBottomSmooth() {
-        binding.messagesList.postDelayed({
-            if (adapter.itemCount > 0) binding.messagesList.scrollToPosition(adapter.itemCount)
-        }, 300)
+    override fun onAddAttachments() {
+        getContent.launch("image/*")
     }
 
-    override fun onCreateOptionsMenu(menu: Menu?): Boolean {
-        // 메뉴 XML을 사용하지 않고 직접 메뉴 아이템 추가
-        menu?.add(0, 1001, 0, "메뉴")?.apply {
-            setIcon(R.drawable.ic_menu)
-            setShowAsAction(MenuItem.SHOW_AS_ACTION_ALWAYS)
-        }
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        menuInflater.inflate(R.menu.chat_menu, menu)
         return true
     }
 
     override fun onOptionsItemSelected(item: MenuItem): Boolean {
         return when (item.itemId) {
-            1001 -> {
-                // 새로운 채팅방 메뉴 액티비티로 이동
-                val intent = Intent(this, ChatRoomMenuActivity::class.java).apply {
-                    putExtra("roomCode", viewModel.roomCode)
-                    putExtra("roomName", supportActionBar?.title?.toString() ?: "채팅방")
+            R.id.action_view_gallery -> {
+                Intent(this, PhotoGalleryActivity::class.java).apply {
+                    putExtra("roomCode", chatRoomId)
+                    startActivity(this)
                 }
-                startActivity(intent)
                 true
             }
-            android.R.id.home -> {
-                finish()
+            R.id.action_ocr -> {
+                Intent(this, OcrActivity::class.java).apply {
+                    putExtra("roomCode", chatRoomId)
+                    startActivity(this)
+                }
                 true
             }
             else -> super.onOptionsItemSelected(item)
         }
     }
 
-    private fun showOcrChoiceDialog() {
-        val options = arrayOf("📸 사진 촬영", "🖼️ 갤러리에서 선택")
-
-        DialogHelper.showStyledChoiceDialog(
-            context = this,
-            title = "영수증 인식 방법 선택",
-            options = options
-        ) { which ->
-            when (which) {
-                0 -> {
-                    Log.d("OCR_CAMERA", "📸 사진 촬영 선택됨")
-                    openOcrCamera()
-                }
-
-                1 -> {
-                    Log.d("OCR_CAMERA", "🖼️ 사진 선택 선택됨")
-                    receiptImageLauncher.launch("image/*")
-                }
+    private fun handleSharedText() {
+        if (intent?.action == Intent.ACTION_SEND && "text/plain" == intent.type) {
+            intent.getStringExtra(Intent.EXTRA_TEXT)?.let {
+                viewModel.sendMessage(chatRoomId!!, it, myUid)
             }
         }
     }
 
-    private fun processOcrWithPeopleInput(bitmap: Bitmap) {
-        val participantsRef = FirebaseDatabase.getInstance()
-            .getReference("rooms")
-            .child(viewModel.roomCode)
-            .child("participants")
-
-        participantsRef.get().addOnSuccessListener { snapshot ->
-            val defaultPeople = snapshot.childrenCount.toInt().coerceAtLeast(1)
-            showParticipantsInputDialog(bitmap, defaultPeople)
-        }.addOnFailureListener { exception ->
-            Log.e("FIREBASE_OCR", "참여자 수 로드 실패. 기본값 사용.", exception)
-            showParticipantsInputDialog(bitmap, 4, "참여자 정보를 가져오지 못했습니다. 기본값(4명)을 사용합니다.")
+    private fun setupToolbar() {
+        setSupportActionBar(binding.toolbar)
+        supportActionBar?.setDisplayHomeAsUpEnabled(true)
+        supportActionBar?.setDisplayShowHomeEnabled(true)
+        binding.toolbar.setNavigationOnClickListener {
+            onBackPressedDispatcher.onBackPressed()
         }
     }
 
-    private fun showParticipantsInputDialog(bitmap: Bitmap, defaultPeopleCount: Int, messageHint: String? = null) {
-        val editText = EditText(this@ChatActivity).apply {
-            setText(defaultPeopleCount.toString())
-            inputType = InputType.TYPE_CLASS_NUMBER
-        }
-
-        val dialogTitle = "정산 인원 수를 입력하세요"
-        val dialogMessage = messageHint ?: "정산 인원을 입력해주세요. (현재 방 인원 자동 반영: ${defaultPeopleCount}명)"
-
-
-        AlertDialog.Builder(this@ChatActivity)
-            .setTitle(dialogTitle)
-            .setMessage(dialogMessage)
-            .setView(editText)
-            .setPositiveButton("확인") { _, _ ->
-                val enteredPeople = editText.text.toString().toIntOrNull()
-                val finalValidPeople = enteredPeople?.takeIf { it > 0 } ?: defaultPeopleCount
-
-                if (enteredPeople != null && enteredPeople <= 0) {
-                    Toast.makeText(this@ChatActivity, "정산 인원은 1명 이상이어야 합니다. 기본값(${defaultPeopleCount}명)으로 설정됩니다.", Toast.LENGTH_LONG).show()
-                }
-
-                lifecycleScope.launch(Dispatchers.Default) {
-                    try {
-                        val ocrText = ReceiptOcrProcessor.processReceipt(this@ChatActivity, bitmap)
-                        val totalAmount = ReceiptOcrProcessor.extractTotalAmount(ocrText)
-                        
-                        if (totalAmount != null && totalAmount > 0) {
-                            val perPerson = totalAmount / finalValidPeople
-                            val message = "📝 영수증 정산\n" +
-                                        "→ 총액: ${totalAmount}원\n" +
-                                        "→ 인원: ${finalValidPeople}명\n" +
-                                        "→ 1인당: ${perPerson}원"
-                            sendChatMessage(message) 
-                        } else {
-                            withContext(Dispatchers.Main) {
-                                Toast.makeText(this@ChatActivity, "영수증 총액을 인식할 수 없습니다.", Toast.LENGTH_SHORT).show()
-                            }
-                        }
-                    } catch (e: Exception) {
-                        Log.e("OCR_PROCESS", "ChatActivity OCR 처리 중 예외", e)
-                        withContext(Dispatchers.Main) {
-                            Toast.makeText(this@ChatActivity, "영수증 인식에 실패했습니다.", Toast.LENGTH_SHORT).show()
-                        }
-                    }
-                }
-            }
-            .setNegativeButton("취소", null)
-            .show()
-    }
-
-    private fun uploadImageToFirebase(uri: Uri) {
-        val fileName = "images/${System.currentTimeMillis()}.jpg"
-        val storageRef = FirebaseStorage.getInstance().reference.child(fileName)
-
-        Log.d("PHOTO", "업로드 시도 URI: $uri")
-
-        storageRef.putFile(uri)
-            .addOnSuccessListener {
-                Log.d("PHOTO", "✅ 업로드 성공")
-                storageRef.downloadUrl.addOnSuccessListener { downloadUrl ->
-                    Log.d("PHOTO", "✅ 다운로드 URL: $downloadUrl")
-                    sendImageMessage(downloadUrl.toString()) // 이때 imageUrlValue로 넣어야 함
-                }
-            }
-            .addOnFailureListener { e ->
-                Log.e("PHOTO", "❌ 업로드 실패: ${e.message}")
-                e.printStackTrace()
-                Toast.makeText(this, "사진 업로드 실패", Toast.LENGTH_SHORT).show()
-            }
-    }
-
-    private fun sendChatMessage(message: String) {
-        Log.d("ChatActivity", "📤 OCR 메시지 전송 시작: $message")
-        viewModel.sendMessage(message)
-        
-        // 메시지 전송 후 자동 스크롤
-        binding.messagesList.post {
-            layoutManager.scrollToPositionWithOffset(adapter.itemCount - 1, 0)
-        }
-    }
-
-    private fun sendImageMessage(imageUrl: String) {
-        Log.d("ChatActivity", "Sending image message: $imageUrl")
-
-        val user = currentUser ?: return
-        val author = Author(
-            user.id,
-            user.nickname ?: "알 수 없음",
-            user.profileImageUrl // ✅ 프로필 이미지 URL 설정
-        )
-
-        val message = ChatMessage(
-            messageId = "",
-            text = "",
-            user = author,
-            imageUrlValue = imageUrl,
-            createdAt = Date()
-        )
-
-        Log.d("🔍 ChatDebug", "adapter senderId = $senderId")
-        Log.d("🔍 ChatDebug", "message sender id = ${message.getUser().getId()}")
-
-        viewModel.sendMessage(message)
-    }
-
-    override fun onDestroy() {
-        super.onDestroy()
-        
-        // OCR 브로드캐스트 리시버 해제
-        try {
-            unregisterReceiver(ocrMessageReceiver)
-            Log.d("ChatActivity_Lifecycle", "OCR 브로드캐스트 리시버 해제 완료")
-        } catch (e: Exception) {
-            Log.w("ChatActivity_Lifecycle", "OCR 브로드캐스트 리시버 해제 실패: ${e.message}")
-        }
-        
-        Log.d("ChatActivity_Lifecycle", "onDestroy 호출됨", Exception("onDestroy Call Stack"))
+    private fun initOpenCV() {
+        if (!OpenCVLoader.initDebug()) {
+            Log.e("OpenCV", "Unable to load OpenCV!")
+        } else {
+            Log.d("OpenCV", "OpenCV loaded successfully!")
+        }
+    }
+
+    private fun checkPermission(permission: String): Boolean {
+        return ContextCompat.checkSelfPermission(this, permission) == PackageManager.PERMISSION_GRANTED
     }
 
-    companion object {
-        const val REQUEST_CAMERA = 1001
-        const val REQUEST_GALLERY = 1002
+    private fun requestPermission(permission: String, requestCode: Int) {
+        ActivityCompat.requestPermissions(this, arrayOf(permission), requestCode)
     }
-}
-class CustomIncomingTextViewHolder(itemView: View) : MessageHolders.IncomingTextMessageViewHolder<ChatMessage>(itemView) {
 
-    override fun onBind(message: ChatMessage) {
-        super.onBind(message)
-
-        val messageTextView = itemView.findViewById<TextView>(R.id.messageText)
-        val rawText = message.text
-        val spannable = SpannableString(rawText)
-
-        Linkify.addLinks(spannable, Linkify.WEB_URLS)
-        processMapUrls(spannable, rawText)
-
-        messageTextView.text = spannable
-        messageTextView.movementMethod = LinkMovementMethod.getInstance()
-        messageTextView.linksClickable = true
-
-        messageTextView.setOnTouchListener { v, event ->
-            val textView = v as TextView
-            val s = textView.text as? Spannable ?: return@setOnTouchListener false
-
-            val action = event.action
-            if (action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_DOWN) {
-                val x = event.x.toInt() - textView.totalPaddingLeft + textView.scrollX
-                val y = event.y.toInt() - textView.totalPaddingTop + textView.scrollY
-
-                val layout = textView.layout ?: return@setOnTouchListener false
-                val line = layout.getLineForVertical(y)
-                val off = layout.getOffsetForHorizontal(line, x.toFloat())
-
-                val links = s.getSpans(off, off, ClickableSpan::class.java)
-                if (links.isNotEmpty()) {
-                    if (action == MotionEvent.ACTION_UP) {
-                        links[0].onClick(textView)
-                    }
-                    return@setOnTouchListener true
-                }
+    override fun onRequestPermissionsResult(
+        requestCode: Int,
+        permissions: Array<out String>,
+        grantResults: IntArray
+    ) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
+        if (grantResults.isNotEmpty() && grantResults[0] == PackageManager.PERMISSION_GRANTED) {
+            if (requestCode == CAMERA_PERMISSION_CODE) {
+                openCamera()
             }
-            return@setOnTouchListener false
-        }
-        // 프로필 이미지 설정
-        val avatarView = itemView.findViewById<ImageView>(R.id.messageUserAvatar)
-        val avatarUrl = message.getUser().getAvatar()
-
-        Log.d("CustomViewHolder", "텍스트 메시지 프로필 이미지 로드: $avatarUrl")
-
-        if (!avatarUrl.isNullOrEmpty()) {
-            Glide.with(itemView.context)
-                .load(avatarUrl)
-                .circleCrop() // 원형으로 표시
-                .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지
-                .into(avatarView)
         } else {
-            avatarView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지
+            Toast.makeText(this, "Permission Denied", Toast.LENGTH_SHORT).show()
         }
-
-        // ✅ 사용자 이름 설정
-        val userNameView = itemView.findViewById<TextView>(R.id.messageUserName)
-        val userName = message.getUser().getName()
-        userNameView.text = if (userName.isNotEmpty()) userName else "알 수 없음"
-
-        Log.d("CustomViewHolder", "사용자 이름 설정: $userName")
-
-        // ✅ 프로필 이미지 클릭 이벤트 추가 (사용자 상세 보기)
-        avatarView.setOnClickListener {
-            showUserDetailDialog(itemView.context, message.getUser())
-        }
-
-        // ✅ 사용자 이름 클릭 이벤트 추가
-        userNameView.setOnClickListener {
-            showUserDetailDialog(itemView.context, message.getUser())
-        }
     }
-
-    private fun processMapUrls(spannable: Spannable, text: String) {
-        // 지도 URL 패턴
-        val mapPatterns = arrayOf(
-            "https://m\\.map\\.naver\\.com[^\\s]*",
-            "https://map\\.naver\\.com[^\\s]*",
-            "https://map\\.kakao\\.com[^\\s]*",
-            "https://maps\\.google\\.com[^\\s]*",
-            "https://www\\.google\\.com/maps[^\\s]*"
-        )
-
-        for (patternStr in mapPatterns) {
-            val pattern = Pattern.compile(patternStr, Pattern.CASE_INSENSITIVE)
-            val matcher = pattern.matcher(text)
-
-            while (matcher.find()) {
-                val start = matcher.start()
-                val end = matcher.end()
-                val mapUrl = text.substring(start, end)
-
-                Log.d("TextMessageViewHolder", "🗺️ 지도 URL 발견: $mapUrl")
-
-                // 기존 URL 링크 제거하고 커스텀 링크로 교체
-                val existingSpans = spannable.getSpans(start, end, ClickableSpan::class.java)
-                for (span in existingSpans) {
-                    spannable.removeSpan(span)
-                }
 
-                // 커스텀 지도 링크 적용
-                val mapClickSpan = object : ClickableSpan() {
-                    override fun onClick(widget: View) {
-                        Log.d("TextMessageViewHolder", "🗺️ 지도 링크 클릭: $mapUrl")
-                        try {
-                            val intent = Intent(widget.context, MapActivity::class.java)
-                            intent.putExtra("mapUrl", mapUrl)
-                            widget.context.startActivity(intent)
-                        } catch (e: Exception) {
-                            Log.e("TextMessageViewHolder", "지도 액티비티 실행 실패", e)
-                        }
-                    }
-                }
-
-                spannable.setSpan(
-                    mapClickSpan,
-                    start,
-                    end,
-                    Spannable.SPAN_EXCLUSIVE_EXCLUSIVE
-                )
+    private fun openCamera() {
+        if (checkPermission(Manifest.permission.CAMERA)) {
+            val values = ContentValues().apply {
+                put(MediaStore.Images.Media.TITLE, "New Picture")
+                put(MediaStore.Images.Media.DESCRIPTION, "From the Camera")
             }
-        }
-    }
-
-    private fun showUserDetailDialog(context: Context, user: com.stfalcon.chatkit.commons.models.IUser) {
-        // ✅ 커스텀 레이아웃 생성
-        val dialogView = LayoutInflater.from(context).inflate(android.R.layout.select_dialog_item, null)
-
-        // LinearLayout을 수동으로 생성하여 이미지와 텍스트를 표시
-        val linearLayout = android.widget.LinearLayout(context).apply {
-            orientation = android.widget.LinearLayout.VERTICAL
-            setPadding(40, 40, 40, 40)
-        }
-
-        // 프로필 이미지 추가
-        val profileImageView = ImageView(context).apply {
-            layoutParams = android.widget.LinearLayout.LayoutParams(300, 300).apply {
-                gravity = Gravity.CENTER_HORIZONTAL
-                bottomMargin = 20
+            photoUri = contentResolver.insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values)
+            val intent = Intent(MediaStore.ACTION_IMAGE_CAPTURE).apply {
+                putExtra(MediaStore.EXTRA_OUTPUT, photoUri)
             }
-            scaleType = ImageView.ScaleType.CENTER_CROP
-            // 둥근 모서리 배경 설정
-            background = ContextCompat.getDrawable(context, android.R.drawable.dialog_frame)
-        }
-
-        // 사용자 정보 텍스트 (ID 제거)
-        val userInfoText = TextView(context).apply {
-            text = "${user.getName()}"
-            textSize = 18f
-            gravity = Gravity.CENTER
-            setPadding(0, 20, 0, 0)
-            setTypeface(null, android.graphics.Typeface.BOLD)
-        }
-
-        // 레이아웃에 뷰들 추가
-        linearLayout.addView(profileImageView)
-        linearLayout.addView(userInfoText)
-
-        // 이미지 로드
-        if (!user.getAvatar().isNullOrEmpty()) {
-            Log.d("UserDialog", "프로필 이미지 로드: ${user.getAvatar()}")
-            Glide.with(context)
-                .load(user.getAvatar())
-                .centerCrop()
-                .error(R.drawable.ic_launcher_background)
-                .into(profileImageView)
+            photoLauncher.launch(intent)
         } else {
-            profileImageView.setImageResource(R.drawable.ic_launcher_background)
-        }
-
-        // 다이얼로그 생성
-        val dialog = AlertDialog.Builder(context)
-            .setTitle("👤 사용자 정보")
-            .setView(linearLayout)
-            .setPositiveButton("확인", null)
-            .setNeutralButton("프로필 크게 보기") { _, _ ->
-                // 프로필 이미지를 전체화면으로 보기
-                showFullScreenImage(context, user.getAvatar())
-            }
-            .create()
-
-        dialog.show()
-    }
-
-    private fun showFullScreenImage(context: Context, imageUrl: String?) {
-        if (imageUrl.isNullOrEmpty()) {
-            Toast.makeText(context, "프로필 이미지가 없습니다.", Toast.LENGTH_SHORT).show()
-            return
-        }
-
-        // 전체화면 이미지 뷰어를 위한 간단한 액티비티 호출
-        // 또는 ImageViewerActivity 재활용
-        val intent = Intent(context, ImageViewerActivity::class.java).apply {
-            putStringArrayListExtra("photoList", arrayListOf(imageUrl))
-            putExtra("startPosition", 0)
-        }
-        context.startActivity(intent)
-    }
-}
-
-class CustomIncomingImageViewHolder(itemView: View) : MessageHolders.IncomingImageMessageViewHolder<ChatMessage>(itemView) {
-
-    override fun onBind(message: ChatMessage) {
-        super.onBind(message)
-
-        // 프로필 이미지 설정
-        val avatarView = itemView.findViewById<ImageView>(R.id.messageUserAvatar)
-        val avatarUrl = message.getUser().getAvatar()
-
-        Log.d("CustomViewHolder", "이미지 메시지 프로필 이미지 로드: $avatarUrl")
-
-        if (!avatarUrl.isNullOrEmpty()) {
-            Glide.with(itemView.context)
-                .load(avatarUrl)
-                .circleCrop() // 원형으로 표시
-                .error(R.drawable.ic_launcher_background) // 에러 시 기본 이미지
-                .into(avatarView)
-        } else {
-            avatarView.setImageResource(R.drawable.ic_launcher_background) // 기본 이미지
-        }
-
-        // ✅ 사용자 이름 설정
-        val userNameView = itemView.findViewById<TextView>(R.id.messageUserName)
-        val userName = message.getUser().getName()
-        userNameView.text = if (userName.isNotEmpty()) userName else "알 수 없음"
-
-        Log.d("CustomViewHolder", "사용자 이름 설정: $userName")
-
-        // ✅ 프로필 이미지 클릭 이벤트 추가 (사용자 상세 보기)
-        avatarView.setOnClickListener {
-            showUserDetailDialog(itemView.context, message.getUser())
-        }
-
-        // ✅ 사용자 이름 클릭 이벤트 추가
-        userNameView.setOnClickListener {
-            showUserDetailDialog(itemView.context, message.getUser())
-        }
-
-        // ✅ 기존 이미지 클릭 기능 유지 (이미지 확대 보기)
-        val imageView = itemView.findViewById<ImageView>(R.id.image)
-        imageView.setOnClickListener {
-            val url = message.imageUrlValue ?: return@setOnClickListener
-            val allImages = ChatImageStore.imageMessages
-            val idx = allImages.indexOf(url)
-            val photoList = if (idx != -1) ArrayList(allImages) else arrayListOf(url)
-            val position = if (idx != -1) idx else 0
-
-            val intent = Intent(itemView.context, ImageViewerActivity::class.java).apply {
-                putStringArrayListExtra("photoList", photoList)
-                putExtra("startPosition", position)
-            }
-
-            itemView.context.startActivity(intent)
-        }
-    }
-
-    private fun showUserDetailDialog(context: Context, user: com.stfalcon.chatkit.commons.models.IUser) {
-        // ✅ 커스텀 레이아웃 생성
-        val linearLayout = android.widget.LinearLayout(context).apply {
-            orientation = android.widget.LinearLayout.VERTICAL
-            setPadding(40, 40, 40, 40)
-        }
-
-        // 프로필 이미지 추가
-        val profileImageView = ImageView(context).apply {
-            layoutParams = android.widget.LinearLayout.LayoutParams(300, 300).apply {
-                gravity = Gravity.CENTER_HORIZONTAL
-                bottomMargin = 20
-            }
-            scaleType = ImageView.ScaleType.CENTER_CROP
-            // 둥근 모서리 배경 설정
-            background = ContextCompat.getDrawable(context, android.R.drawable.dialog_frame)
-        }
-
-        // 사용자 정보 텍스트 (ID 제거)
-        val userInfoText = TextView(context).apply {
-            text = "${user.getName()}"
-            textSize = 18f
-            gravity = Gravity.CENTER
-            setPadding(0, 20, 0, 0)
-            setTypeface(null, android.graphics.Typeface.BOLD)
-        }
-
-        // 레이아웃에 뷰들 추가
-        linearLayout.addView(profileImageView)
-        linearLayout.addView(userInfoText)
-
-        // 이미지 로드
-        if (!user.getAvatar().isNullOrEmpty()) {
-            Log.d("UserDialog", "프로필 이미지 로드: ${user.getAvatar()}")
-            Glide.with(context)
-                .load(user.getAvatar())
-                .centerCrop()
-                .error(R.drawable.ic_launcher_background)
-                .into(profileImageView)
-        } else {
-            profileImageView.setImageResource(R.drawable.ic_launcher_background)
+            requestPermission(Manifest.permission.CAMERA, CAMERA_PERMISSION_CODE)
         }
-
-        // 다이얼로그 생성
-        val dialog = AlertDialog.Builder(context)
-            .setTitle("👤 사용자 정보")
-            .setView(linearLayout)
-            .setPositiveButton("확인", null)
-            .setNeutralButton("프로필 크게 보기") { _, _ ->
-                // 프로필 이미지를 전체화면으로 보기
-                showFullScreenImage(context, user.getAvatar())
-            }
-            .create()
+    }
 
-        dialog.show()
-    }
-
-    private fun showFullScreenImage(context: Context, imageUrl: String?) {
-        if (imageUrl.isNullOrEmpty()) {
-            Toast.makeText(context, "프로필 이미지가 없습니다.", Toast.LENGTH_SHORT).show()
-            return
-        }
-
-        // 전체화면 이미지 뷰어를 위한 간단한 액티비티 호출
-        // 또는 ImageViewerActivity 재활용
-        val intent = Intent(context, ImageViewerActivity::class.java).apply {
-            putStringArrayListExtra("photoList", arrayListOf(imageUrl))
-            putExtra("startPosition", 0)
-        }
-        context.startActivity(intent)
+    companion object {
+        private const val CAMERA_PERMISSION_CODE = 101
     }
-}
\ No newline at end of file
+} 
\ No newline at end of file
Index: app/build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import org.gradle.kotlin.dsl.implementation\n\nplugins {\n    id(\"com.google.devtools.ksp\")\n    id(\"com.android.application\")\n    id(\"org.jetbrains.kotlin.android\")\n    id(\"org.jetbrains.kotlin.kapt\")\n    id(\"com.google.gms.google-services\")\n}\n\nandroid {\n    namespace = \"com.example.andapp1\"\n    compileSdk = 35\n    ksp {\n        arg(\"room.schemaLocation\", \"$projectDir/schemas\")\n    }\n    defaultConfig {\n        applicationId = \"com.example.andapp1\"\n        minSdk = 23\n        targetSdk = 35\n        versionCode = 1\n        versionName = \"1.0\"\n\n    }\n\n    buildTypes {\n        release {\n            isMinifyEnabled = false\n            proguardFiles(\n                getDefaultProguardFile(\"proguard-android-optimize.txt\"),\n                \"proguard-rules.pro\"\n            )\n        }\n    }\n\n    buildFeatures {\n        buildConfig = true\n        viewBinding = true\n    }\n\n    compileOptions {\n        sourceCompatibility = JavaVersion.VERSION_17\n        targetCompatibility = JavaVersion.VERSION_17\n    }\n\n    kotlinOptions {\n        jvmTarget = \"17\"\n    }\n}\nksp {\n    arg(\"room.schemaLocation\", \"$projectDir/schemas\")\n}\ndependencies {\n    //카카오\n    implementation(\"com.kakao.sdk:v2-talk:2.21.1\")\n    implementation(\"com.kakao.sdk:v2-share:2.21.1\")\n    implementation(\"com.kakao.sdk:v2-user:2.21.1\")\n    // Firebase\n    implementation(platform(\"com.google.firebase:firebase-bom:33.12.0\"))\n    implementation (\"com.google.firebase:firebase-storage-ktx\")\n    implementation(\"com.google.firebase:firebase-database-ktx\")\n    implementation(\"com.google.firebase:firebase-database:21.0.0\")\n    implementation(\"com.google.firebase:firebase-analytics:22.4.0\")\n\n    // UI + 라이브러리\n\n    implementation (\"androidx.annotation:annotation:1.7.0\")\n    implementation(\"androidx.appcompat:appcompat:1.7.0\")\n    implementation(\"com.google.android.material:material:1.12.0\")\n    implementation(\"androidx.constraintlayout:constraintlayout:2.1.4\")\n    implementation(\"androidx.core:core-ktx:1.12.0\")\n    implementation(\"com.google.android.flexbox:flexbox:3.0.0\")\n    // Room\n    implementation(\"androidx.room:room-runtime:2.6.1\")\n    implementation(\"androidx.room:room-ktx:2.6.1\")\n    implementation (\"androidx.lifecycle:lifecycle-livedata-ktx:2.8.7\")\n    ksp(\"androidx.room:room-compiler:2.6.1\")\n\n    // Lifecycle\n    implementation(\"androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0\")\n\n    // Glide\n    implementation(\"com.github.bumptech.glide:glide:4.16.0\")\n    kapt(\"com.github.bumptech.glide:compiler:4.16.0\")\n\n    // 내부 프로젝트\n    implementation(project(\":chatkit\"))\n    implementation(\"cz.adaptech.tesseract4android:tesseract4android:4.7.0\")\n    // OpenCV Maven Central 의존성 (4.9.0+)\n    implementation(\"org.opencv:opencv:4.10.0\")\n    implementation (\"com.airbnb.android:lottie:6.4.0\")\n\n    //채팅 메시지 알림\n    implementation (\"com.google.firebase:firebase-messaging\")\n    implementation(\"com.squareup.okhttp3:okhttp:4.11.0\")\n\n    // CameraX 의존성\n    implementation(\"androidx.camera:camera-core:1.3.4\")\n    implementation(\"androidx.camera:camera-camera2:1.3.4\")\n    implementation(\"androidx.camera:camera-lifecycle:1.3.4\")\n    implementation(\"androidx.camera:camera-view:1.3.4\")\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/build.gradle.kts b/app/build.gradle.kts
--- a/app/build.gradle.kts	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/build.gradle.kts	(date 1749723512070)
@@ -1,26 +1,38 @@
 import org.gradle.kotlin.dsl.implementation
+import java.util.Properties
 
 plugins {
     id("com.google.devtools.ksp")
     id("com.android.application")
     id("org.jetbrains.kotlin.android")
-    id("org.jetbrains.kotlin.kapt")
+    id("kotlin-kapt")
     id("com.google.gms.google-services")
+    id("com.google.dagger.hilt.android")
+}
+
+// local.properties 파일 로드
+val localProperties = Properties().apply {
+    load(project.rootProject.file("local.properties").inputStream())
 }
 
 android {
     namespace = "com.example.andapp1"
     compileSdk = 35
-    ksp {
-        arg("room.schemaLocation", "$projectDir/schemas")
-    }
+    
     defaultConfig {
         applicationId = "com.example.andapp1"
         minSdk = 23
         targetSdk = 35
         versionCode = 1
         versionName = "1.0"
+        testInstrumentationRunner = "com.example.andapp1.HiltTestRunner"
 
+        // BuildConfig 필드에 카카오 네이티브 앱 키 추가
+        buildConfigField(
+            "String",
+            "KAKAO_NATIVE_APP_KEY",
+            localProperties.getProperty("KAKAO_NATIVE_APP_KEY")
+        )
     }
 
     buildTypes {
@@ -46,10 +58,13 @@
     kotlinOptions {
         jvmTarget = "17"
     }
-}
-ksp {
-    arg("room.schemaLocation", "$projectDir/schemas")
+    
+    // Add kapt options
+    kapt {
+        correctErrorTypes = true
+    }
 }
+
 dependencies {
     //카카오
     implementation("com.kakao.sdk:v2-talk:2.21.1")
@@ -59,8 +74,8 @@
     implementation(platform("com.google.firebase:firebase-bom:33.12.0"))
     implementation ("com.google.firebase:firebase-storage-ktx")
     implementation("com.google.firebase:firebase-database-ktx")
-    implementation("com.google.firebase:firebase-database:21.0.0")
-    implementation("com.google.firebase:firebase-analytics:22.4.0")
+    implementation("com.google.firebase:firebase-database")
+    implementation("com.google.firebase:firebase-analytics")
 
     // UI + 라이브러리
 
@@ -81,7 +96,11 @@
 
     // Glide
     implementation("com.github.bumptech.glide:glide:4.16.0")
-    kapt("com.github.bumptech.glide:compiler:4.16.0")
+    ksp("com.github.bumptech.glide:ksp:4.16.0")
+
+    // Hilt
+    implementation("com.google.dagger:hilt-android:2.51.1")
+    kapt("com.google.dagger:hilt-compiler:2.51.1")
 
     // 내부 프로젝트
     implementation(project(":chatkit"))
@@ -100,4 +119,16 @@
     implementation("androidx.camera:camera-lifecycle:1.3.4")
     implementation("androidx.camera:camera-view:1.3.4")
 
+    // Test Dependencies
+    testImplementation("junit:junit:4.13.2")
+    testImplementation("org.mockito:mockito-core:4.11.0")
+    testImplementation("org.mockito.kotlin:mockito-kotlin:4.1.0")
+    testImplementation("org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3")
+    testImplementation("app.cash.turbine:turbine:1.1.0")
+    testImplementation("androidx.arch.core:core-testing:2.2.0")
+
+    androidTestImplementation("androidx.test.ext:junit:1.2.1")
+    androidTestImplementation("androidx.test.espresso:espresso-core:3.6.1")
+    androidTestImplementation("com.google.dagger:hilt-android-testing:2.51.1")
+    kaptAndroidTest("com.google.dagger:hilt-compiler:2.51.1")
 }
\ No newline at end of file
Index: build.gradle.kts
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>plugins {\n        id(\"com.android.library\") version \"8.3.2\" apply false\n        id(\"com.android.application\") version \"8.3.2\" apply false\n        kotlin(\"android\") version \"2.1.20\" apply false\n        kotlin(\"jvm\") version \"2.1.20\" apply false\n        id(\"com.google.gms.google-services\") version \"4.4.2\" apply false\n        id(\"com.google.devtools.ksp\") version \"2.1.20-1.0.32\" apply false\n        }\n\nbuildscript {\n    repositories {\n        google()\n        mavenCentral()\n        jcenter()\n        maven { url = uri(\"https://devrepo.kakao.com/nexus/content/groups/public/\") }\n    }\n    dependencies {\n        classpath(\"com.android.tools.build:gradle:8.9.0\") // ✅ 최신 AGP 8.4.0으로 업그레이드\n    }\n}\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/build.gradle.kts b/build.gradle.kts
--- a/build.gradle.kts	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/build.gradle.kts	(date 1749649851364)
@@ -1,20 +1,9 @@
 plugins {
-        id("com.android.library") version "8.3.2" apply false
-        id("com.android.application") version "8.3.2" apply false
-        kotlin("android") version "2.1.20" apply false
-        kotlin("jvm") version "2.1.20" apply false
-        id("com.google.gms.google-services") version "4.4.2" apply false
-        id("com.google.devtools.ksp") version "2.1.20-1.0.32" apply false
-        }
-
-buildscript {
-    repositories {
-        google()
-        mavenCentral()
-        jcenter()
-        maven { url = uri("https://devrepo.kakao.com/nexus/content/groups/public/") }
-    }
-    dependencies {
-        classpath("com.android.tools.build:gradle:8.9.0") // ✅ 최신 AGP 8.4.0으로 업그레이드
-    }
+    id("com.android.library") version "8.3.2" apply false
+    id("com.android.application") version "8.3.2" apply false
+    kotlin("android") version "2.1.20" apply false
+    kotlin("jvm") version "2.1.20" apply false
+    id("com.google.gms.google-services") version "4.4.2" apply false
+    id("com.google.devtools.ksp") version "2.1.20-1.0.32" apply false
+    id("com.google.dagger.hilt.android") version "2.51.1" apply false
 }
Index: app/src/main/java/com/example/andapp1/ChatViewModelFactory.kt
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/ChatViewModelFactory.kt b/app/src/main/java/com/example/andapp1/ChatViewModelFactory.kt
deleted file mode 100644
--- a/app/src/main/java/com/example/andapp1/ChatViewModelFactory.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ /dev/null	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
@@ -1,17 +0,0 @@
-package com.example.andapp1
-
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.ViewModelProvider
-import android.content.Context
-
-class ChatViewModelFactory(
-    private val roomCode: String,
-    private val context: Context
-) : ViewModelProvider.Factory {
-    override fun <T : ViewModel> create(modelClass: Class<T>): T {
-        if (modelClass.isAssignableFrom(ChatViewModel::class.java)) {
-            return ChatViewModel(roomCode, context) as T
-        }
-        throw IllegalArgumentException("Unknown ViewModel class")
-    }
-}
\ No newline at end of file
Index: app/src/main/java/com/example/andapp1/MainViewModelFactory.kt
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/MainViewModelFactory.kt b/app/src/main/java/com/example/andapp1/MainViewModelFactory.kt
deleted file mode 100644
--- a/app/src/main/java/com/example/andapp1/MainViewModelFactory.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ /dev/null	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
@@ -1,15 +0,0 @@
-package com.example.andapp1
-
-import android.content.Context
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.ViewModelProvider
-
-class MainViewModelFactory(
-    private val context: Context
-) : ViewModelProvider.Factory {
-    override fun <T : ViewModel> create(modelClass: Class<T>): T {
-        val db = RoomDatabaseInstance.getInstance(context)
-        val repository = RoomRepository(db) // ✅ AppDatabase 넘겨줌
-        return MainViewModel(repository, context) as T
-    }
-}
\ No newline at end of file
Index: app/src/main/java/com/example/andapp1/ChatViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//ChatViewModel.kt\npackage com.example.andapp1\n\nimport android.R.attr.text\nimport android.util.Log\nimport android.util.Property\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.viewModelScope\nimport com.example.andapp1.ChatMessage\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.runBlocking\nimport kotlinx.coroutines.withContext\nimport java.util.*\nimport android.content.Context\nimport com.google.firebase.database.FirebaseDatabase\n\nclass ChatViewModel(val roomCode: String,\n                    val context: Context) : ViewModel() {\n\n    private val messageRepository = MessageRepository(roomCode)\n    val messages: LiveData<List<ChatMessage>> = messageRepository.messages\n\n    private val userDao = RoomDatabaseInstance.getInstance(context).userDao()\n\n    fun sendMessage(content: String) {\n        val userDao = RoomDatabaseInstance.getInstance(context).userDao()\n\n        // 코루틴으로 Room에서 사용자 불러오기\n        viewModelScope.launch {\n            val currentUser = withContext(Dispatchers.IO) {\n                userDao.getUser()\n            }\n\n            if (currentUser != null) {\n                // ✅ 디버깅 로그 추가\n                Log.d(\"ProfileDebug\", \"=== 메시지 전송 시 프로필 디버깅 ===\")\n                Log.d(\"ProfileDebug\", \"사용자 ID: ${currentUser.id}\")\n                Log.d(\"ProfileDebug\", \"사용자 닉네임: ${currentUser.nickname}\")\n                Log.d(\"ProfileDebug\", \"프로필 이미지 URL: ${currentUser.profileImageUrl}\")\n\n                val user = Author(\n                    id = currentUser.id,\n                    name = currentUser.nickname ?: \"알 수 없음\",\n                    avatar = currentUser.profileImageUrl // ✅ 프로필 이미지 URL 설정\n                )\n\n                Log.d(\"ProfileDebug\", \"Author avatar 설정됨: ${user.getAvatar()}\")\n\n                val message = ChatMessage(\n                    messageId = \"\",\n                    text = content,\n                    user = user,\n                    createdAt = Date()\n                )\n                Log.d(\"ChatViewModel\", \"\uD83D\uDCE4 메시지 전송: ${message.text}\")\n                messageRepository.sendMessage(message)\n            } else {\n                Log.e(\"ChatViewModel\", \"❌ 사용자 정보가 없습니다. 메시지를 보낼 수 없습니다.\")\n            }\n        }\n    }\n\n    fun sendSystemMessage(text: String) {\n        viewModelScope.launch {\n            val message = ChatMessage(\n                messageId = \"\",\n                text = text,\n                user = Author(\n                    id = \"system\",\n                    name = \"시스템\",\n                    avatar = null\n                ),\n                createdAt = Date()\n            )\n            Log.d(\"ChatViewModel\", \"⚙\uFE0F 시스템 메시지 전송: $text\")\n            messageRepository.sendMessage(message)\n        }\n    }\n\n    fun sendMapUrlMessage(mapUrl: String) {\n        viewModelScope.launch {\n            val currentUser = withContext(Dispatchers.IO) {\n                userDao.getUser()\n            }\n\n            if (currentUser != null) {\n                val user = Author(\n                    id = currentUser.id,\n                    name = currentUser.nickname ?: \"알 수 없음\",\n                    avatar = currentUser.profileImageUrl // ✅ 프로필 이미지 URL 설정\n                )\n\n                val message = ChatMessage(\n                    messageId = \"\",\n                    text = \"\uD83D\uDDFA\uFE0F 장소를 공유했어요!\\n$mapUrl\", // ✅ URL도 텍스트에 포함\n                    user = user,\n                    imageUrlValue= null,\n                    mapUrl = mapUrl,\n                    createdAt = Date()\n                )\n                Log.d(\"ChatViewModel\", \"\uD83D\uDCE4 지도 URL 전송: $mapUrl\")\n                messageRepository.sendMessage(message)\n            } else {\n                Log.e(\"ChatViewModel\", \"❌ 사용자 정보 없음\")\n            }\n        }\n    }\n\n    fun sendMessage(message: ChatMessage) {\n        viewModelScope.launch {\n            messageRepository.sendMessage(message)\n        }\n    }\n\n    override fun onCleared() {\n        super.onCleared()\n        messageRepository.cleanup()\n    }\n\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/ChatViewModel.kt b/app/src/main/java/com/example/andapp1/ChatViewModel.kt
--- a/app/src/main/java/com/example/andapp1/ChatViewModel.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/ChatViewModel.kt	(date 1749652188685)
@@ -1,122 +1,115 @@
 //ChatViewModel.kt
 package com.example.andapp1
 
-import android.R.attr.text
+import android.app.Application
+import android.net.Uri
 import android.util.Log
-import android.util.Property
+import androidx.lifecycle.AndroidViewModel
 import androidx.lifecycle.LiveData
-import androidx.lifecycle.ViewModel
 import androidx.lifecycle.viewModelScope
-import com.example.andapp1.ChatMessage
+import com.google.firebase.auth.FirebaseAuth
+import com.google.firebase.database.FirebaseDatabase
+import com.google.firebase.storage.FirebaseStorage
 import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.flow.MutableStateFlow
+import kotlinx.coroutines.flow.StateFlow
+import kotlinx.coroutines.flow.asStateFlow
 import kotlinx.coroutines.launch
-import kotlinx.coroutines.runBlocking
-import kotlinx.coroutines.withContext
+import kotlinx.coroutines.tasks.await
 import java.util.*
-import android.content.Context
-import com.google.firebase.database.FirebaseDatabase
+import com.example.andapp1.models.Message
+import dagger.hilt.android.lifecycle.HiltViewModel
+import javax.inject.Inject
 
-class ChatViewModel(val roomCode: String,
-                    val context: Context) : ViewModel() {
+@HiltViewModel
+class ChatViewModel @Inject constructor(
+    application: Application,
+    private val messageRepository: MessageRepository,
+    private val storageRepository: StorageRepository
+) : AndroidViewModel(application) {
 
-    private val messageRepository = MessageRepository(roomCode)
-    val messages: LiveData<List<ChatMessage>> = messageRepository.messages
+    private val _messages = MutableStateFlow<List<Message>>(emptyList())
+    val messages: StateFlow<List<Message>> = _messages.asStateFlow()
 
-    private val userDao = RoomDatabaseInstance.getInstance(context).userDao()
+    private val _imageUploadResult = MutableStateFlow<Result<String>?>(null)
+    val imageUploadResult: StateFlow<Result<String>?> = _imageUploadResult.asStateFlow()
 
-    fun sendMessage(content: String) {
-        val userDao = RoomDatabaseInstance.getInstance(context).userDao()
-
-        // 코루틴으로 Room에서 사용자 불러오기
+    fun loadMessages(chatRoomId: String) {
         viewModelScope.launch {
-            val currentUser = withContext(Dispatchers.IO) {
-                userDao.getUser()
+            messageRepository.getMessages(chatRoomId).collect { messagesList ->
+                _messages.value = messagesList
             }
-
-            if (currentUser != null) {
-                // ✅ 디버깅 로그 추가
-                Log.d("ProfileDebug", "=== 메시지 전송 시 프로필 디버깅 ===")
-                Log.d("ProfileDebug", "사용자 ID: ${currentUser.id}")
-                Log.d("ProfileDebug", "사용자 닉네임: ${currentUser.nickname}")
-                Log.d("ProfileDebug", "프로필 이미지 URL: ${currentUser.profileImageUrl}")
-
-                val user = Author(
-                    id = currentUser.id,
-                    name = currentUser.nickname ?: "알 수 없음",
-                    avatar = currentUser.profileImageUrl // ✅ 프로필 이미지 URL 설정
-                )
-
-                Log.d("ProfileDebug", "Author avatar 설정됨: ${user.getAvatar()}")
+        }
+    }
 
-                val message = ChatMessage(
-                    messageId = "",
-                    text = content,
-                    user = user,
-                    createdAt = Date()
-                )
-                Log.d("ChatViewModel", "📤 메시지 전송: ${message.text}")
-                messageRepository.sendMessage(message)
-            } else {
-                Log.e("ChatViewModel", "❌ 사용자 정보가 없습니다. 메시지를 보낼 수 없습니다.")
-            }
+    fun sendMessage(chatRoomId: String, text: String, senderId: String) {
+        viewModelScope.launch {
+            messageRepository.sendMessage(chatRoomId, text, senderId)
         }
     }
 
-    fun sendSystemMessage(text: String) {
+    fun uploadImage(chatRoomId: String, imageUri: Uri) {
         viewModelScope.launch {
-            val message = ChatMessage(
-                messageId = "",
-                text = text,
-                user = Author(
-                    id = "system",
-                    name = "시스템",
-                    avatar = null
-                ),
-                createdAt = Date()
-            )
-            Log.d("ChatViewModel", "⚙️ 시스템 메시지 전송: $text")
-            messageRepository.sendMessage(message)
-        }
+            val result = storageRepository.uploadImage(chatRoomId, imageUri)
+            _imageUploadResult.value = result
+        }
+    }
+
+    fun sendImageMessage(uri: Uri) {
+        val currentUser = FirebaseAuth.getInstance().currentUser
+        val chatId = _currentChatRoomId ?: return
+        
+        if (currentUser == null) {
+            Log.e("ChatViewModel", "Current user is null")
+            return
+        }
+
+        viewModelScope.launch {
+            try {
+                val imageUrl = storageRepository.uploadImage(chatId, uri)
+                messageRepository.sendImageMessage(chatId, imageUrl, currentUser.uid)
+            } catch (e: Exception) {
+                Log.e("ChatViewModel", "Failed to send image message", e)
+            }
+        }
+    }
+
+    fun sendSystemMessage(text: String) {
+        val message = ChatMessage(
+            text = text,
+            user = Author(id = "system", name = "System", avatar = null),
+            createdAt = Date()
+        )
+        messageRepository.sendMessage(message)
+        Log.d("ChatViewModel", "⚙️ System message sent: $text")
     }
 
     fun sendMapUrlMessage(mapUrl: String) {
-        viewModelScope.launch {
-            val currentUser = withContext(Dispatchers.IO) {
-                userDao.getUser()
-            }
-
-            if (currentUser != null) {
-                val user = Author(
-                    id = currentUser.id,
-                    name = currentUser.nickname ?: "알 수 없음",
-                    avatar = currentUser.profileImageUrl // ✅ 프로필 이미지 URL 설정
-                )
-
-                val message = ChatMessage(
-                    messageId = "",
-                    text = "🗺️ 장소를 공유했어요!\n$mapUrl", // ✅ URL도 텍스트에 포함
-                    user = user,
-                    imageUrlValue= null,
-                    mapUrl = mapUrl,
-                    createdAt = Date()
-                )
-                Log.d("ChatViewModel", "📤 지도 URL 전송: $mapUrl")
-                messageRepository.sendMessage(message)
-            } else {
-                Log.e("ChatViewModel", "❌ 사용자 정보 없음")
-            }
-        }
+        val user = _currentUser.value ?: return
+        val author = Author(
+            id = user.id,
+            name = user.nickname ?: "Unknown",
+            avatar = user.profileImageUrl
+        )
+        val message = ChatMessage(
+            text = "🗺️ A place has been shared!\n$mapUrl",
+            user = author,
+            mapUrl = mapUrl,
+            createdAt = Date()
+        )
+        messageRepository.sendMessage(message)
+        Log.d("ChatViewModel", "📤 Map URL sent: $mapUrl")
     }
 
-    fun sendMessage(message: ChatMessage) {
-        viewModelScope.launch {
-            messageRepository.sendMessage(message)
-        }
+    private var _currentChatRoomId: String? = null
+    
+    fun setChatRoomId(chatRoomId: String) {
+        _currentChatRoomId = chatRoomId
     }
 
     override fun onCleared() {
         super.onCleared()
         messageRepository.cleanup()
+        Log.d("ChatViewModel", "ViewModel cleared and resources released.")
     }
-
 }
\ No newline at end of file
Index: app/src/main/AndroidManifest.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    xmlns:tools=\"http://schemas.android.com/tools\">\n    <uses-permission android:name=\"android.permission.INTERNET\"/>\n    <uses-permission android:name=\"android.permission.READ_MEDIA_IMAGES\" />\n    <uses-feature android:name=\"android.hardware.camera\" android:required=\"false\" />\n    <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\"\n        android:maxSdkVersion=\"28\"/>\n    <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n    <!-- Android 14 이상 -->\n    <uses-permission android:name=\"android.permission.READ_MEDIA_VISUAL_USER_SELECTED\" />\n    <!-- 카메라 권한 -->\n    <uses-permission android:name=\"android.permission.CAMERA\" />\n    <!-- 채팅방 알림 -->\n    <uses-permission android:name=\"android.permission.POST_NOTIFICATIONS\"/>\n\n\n    <application\n        android:allowBackup=\"true\"\n        android:requestLegacyExternalStorage=\"true\"\n        android:dataExtractionRules=\"@xml/data_extraction_rules\"\n        android:fullBackupContent=\"@xml/backup_rules\"\n        android:label=\"@string/app_name\"\n        android:icon=\"@mipmap/ic_launcher\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.AndApp1\"\n        tools:targetApi=\"31\">\n        <activity android:name=\".ChatActivity\"\n            android:theme=\"@style/Theme.Chat.Default\"\n            android:launchMode=\"singleTop\"\n            android:windowSoftInputMode=\"adjustResize\"\n            android:exported=\"true\">\n\n            <!-- 공유 인텐트 수신 -->\n            <intent-filter>\n                <action android:name=\"android.intent.action.SEND\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <data android:mimeType=\"text/plain\" />\n            </intent-filter>\n        </activity>\n\n\n        <!-- 카카오톡 -->\n        <meta-data\n            android:name=\"com.kakao.sdk.AppKey\"\n            android:value=\"@string/kakao_native_app_key\"/>\n\n        <activity android:name=\".RoomActivity\" android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data\n                    android:host=\"room\"\n                    android:scheme=\"myapp\" />\n            </intent-filter>\n        </activity>\n\n        <activity android:name=\"com.kakao.sdk.auth.AuthCodeHandlerActivity\"\n            android:exported=\"true\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data android:scheme=\"kakaoffb04602d82950f1b00de0324a38f023\" android:host=\"oauth\" />\n            </intent-filter>\n        </activity>\n\n        <activity\n            android:name=\".SplashActivity\"\n            android:exported=\"true\"\n            android:theme=\"@style/Theme.AndApp1\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n\n        <activity android:name=\".LoginActivity\"\n            android:exported=\"true\">\n        </activity>\n\n        <!-- ✅ MainActivity 테마를 Theme.AndApp1로 변경 -->\n        <activity android:name=\".MainActivity\"\n            android:theme=\"@style/Theme.AndApp1\"\n            android:exported=\"true\">\n            <intent-filter android:label=\"room link\">\n                <action android:name=\"android.intent.action.VIEW\" />\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <data\n                    android:scheme=\"https\"\n                    android:host=\"example.com\"\n                    android:pathPrefix=\"/room\" />\n            </intent-filter>\n        </activity>\n\n        <activity android:name=\".MapActivity\" />\n        <activity android:name=\".ImageViewerActivity\" />\n        <activity android:name=\".PhotoViewerActivity\" />\n        <activity\n            android:name=\".PhotoGalleryActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ChatActivity\" />\n        <activity\n            android:name=\".ocr.OcrActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ChatActivity\"\n            android:theme=\"@style/Theme.Chat.Default\" />\n        <activity\n            android:name=\".expense.TravelExpenseActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ChatActivity\"\n            android:theme=\"@style/Theme.Chat.Default\" />\n        <activity\n            android:name=\".ocr.RoiImageEditorActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ocr.OcrActivity\"\n            android:theme=\"@style/Theme.Chat.Default\" />\n        <activity\n            android:name=\".ocr.RoiCameraActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ocr.OcrActivity\"\n            android:theme=\"@style/Theme.Chat.Default\" />\n        <activity\n            android:name=\".ChatRoomMenuActivity\"\n            android:exported=\"false\"\n            android:parentActivityName=\".ChatActivity\"\n            android:theme=\"@style/Theme.Chat.Default\" />\n\n        <provider\n            android:name=\"androidx.core.content.FileProvider\"\n            android:authorities=\"${applicationId}.fileprovider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/file_paths\" />\n        </provider>\n\n        <service\n            android:name=\".MyFirebaseMessagingService\"\n            android:exported=\"false\">\n            <intent-filter>\n                <action android:name=\"com.google.firebase.MESSAGING_EVENT\"/>\n            </intent-filter>\n        </service>\n\n        <meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_icon\"\n            android:resource=\"@mipmap/ic_launcher\" />\n        <meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_color\"\n            android:resource=\"@color/colorAccent\" />\n        <meta-data\n            android:name=\"com.google.firebase.messaging.default_notification_channel_id\"\n            android:value=\"fcm_default_channel\" />\n\n    </application>\n</manifest>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/AndroidManifest.xml b/app/src/main/AndroidManifest.xml
--- a/app/src/main/AndroidManifest.xml	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/AndroidManifest.xml	(date 1749647522428)
@@ -16,6 +16,7 @@
 
 
     <application
+        android:name=".GlobalApplication"
         android:allowBackup="true"
         android:requestLegacyExternalStorage="true"
         android:dataExtractionRules="@xml/data_extraction_rules"
@@ -41,11 +42,6 @@
         </activity>
 
 
-        <!-- 카카오톡 -->
-        <meta-data
-            android:name="com.kakao.sdk.AppKey"
-            android:value="@string/kakao_native_app_key"/>
-
         <activity android:name=".RoomActivity" android:exported="true">
             <intent-filter>
                 <action android:name="android.intent.action.VIEW" />
Index: app/src/main/java/com/example/andapp1/LoginActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.andapp1\n\nimport android.content.Context\nimport android.content.Context.MODE_PRIVATE\nimport android.content.Intent\nimport android.content.pm.PackageManager\nimport android.os.Bundle\nimport android.util.Base64\nimport android.util.Log\nimport android.widget.Toast\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.content.ContextCompat.startActivity\nimport androidx.lifecycle.lifecycleScope\nimport com.example.andapp1.MainActivity\nimport com.example.andapp1.databinding.ActivityLoginBinding\nimport com.google.firebase.database.FirebaseDatabase\nimport com.google.firebase.database.ktx.database\nimport com.google.firebase.ktx.Firebase\nimport com.kakao.sdk.common.KakaoSdk\nimport com.kakao.sdk.user.UserApiClient\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\nimport java.security.MessageDigest\n\n// LoginActivity.kt\nclass LoginActivity : AppCompatActivity() {\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        val binding = ActivityLoginBinding.inflate(layoutInflater)\n        setContentView(binding.root)\n        // 카카오 로그인 초기화\n        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))\n        printKeyHash(this) // \uD83D\uDC48 여기서 호출\n\n        binding.kakaoLoginButton.setOnClickListener {\n            Log.d(\"Login\", \"카카오 로그인 버튼 클릭됨\")\n            if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {\n                UserApiClient.instance.loginWithKakaoTalk(this) { token, error ->\n                    if (token != null) {\n                        Log.d(\"Login\", \"토큰 받음 ✅: ${token.accessToken}\")\n                        fetchKakaoUserInfo()\n                    } else {\n                        Log.e(\"Login\", \"카카오톡 로그인 실패: ${error?.message}\")\n                    }\n                }\n            } else {\n                UserApiClient.instance.loginWithKakaoAccount(this) { token, error ->\n                    if (error != null) {\n                        Log.e(\"Login\", \"카카오 계정 로그인 실패 ❌\", error)\n                        Toast.makeText(this, \"로그인 실패: ${error.message}\", Toast.LENGTH_SHORT).show()\n                    } else if (token != null) {\n                        Log.d(\"Login\", \"카카오 계정 로그인 성공 ✅: ${token.accessToken}\")\n                        fetchKakaoUserInfo()\n                    } else {\n                        Log.e(\"Login\", \"로그인 실패: token도 error도 null임 ❗\")\n                        Toast.makeText(this, \"알 수 없는 로그인 오류 발생\", Toast.LENGTH_SHORT).show()\n                    }\n                }\n            }\n        }\n    }\n    fun printKeyHash(context: Context) {\n        try {\n            val info = context.packageManager.getPackageInfo(\n                context.packageName,\n                PackageManager.GET_SIGNATURES\n            )\n\n            info.signatures?.let { signatures ->\n                for (signature in signatures) {\n                    val md = MessageDigest.getInstance(\"SHA\")\n                    md.update(signature.toByteArray())\n                    val hashKey = Base64.encodeToString(md.digest(), Base64.NO_WRAP)\n                    Log.d(\"HashKey\", \"keyhash: $hashKey\")\n                }\n            }\n        } catch (e: Exception) {\n            Log.e(\"HashKey\", \"Error printing KeyHash: ${e.message}\")\n        }\n    }\n    private fun fetchKakaoUserInfo() {\n        UserApiClient.instance.me { user, error ->\n            if (error != null) {\n                Log.e(\"Login\", \"사용자 정보 불러오기 실패 ❌: ${error.message}\")\n            }\n            if (user != null) {\n                Log.d(\"Login\", \"사용자 정보 불러오기 성공 ✅: ${user.kakaoAccount?.profile?.nickname}\")\n                val userId = user.id.toString()\n                val nickname = user.kakaoAccount?.profile?.nickname ?: \"\"\n                val email = user.kakaoAccount?.email ?: \"\"\n                val profileImageUrl = user.kakaoAccount?.profile?.profileImageUrl\n                saveUserToFirebaseAndRoom(userId, nickname, email, profileImageUrl)\n\n                // 자동 로그인용 사용자 ID를 저장\n                val prefs = getSharedPreferences(\"login\", MODE_PRIVATE)\n                prefs.edit().putString(\"userId\", userId).apply()\n\n                // MainActivity로 이동\n                Log.d(\"Login\", \"MainActivity로 이동합니다.\")\n                val intent = Intent(this, MainActivity::class.java)\n                intent.flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_ACTIVITY_CLEAR_TASK\n                startActivity(intent)\n                finish()\n            } else {\n                Log.e(\"Login\", \"user가 null임 ❗\")\n                Toast.makeText(this, \"로그인에 실패했습니다. 다시 시도해주세요.\", Toast.LENGTH_SHORT).show()\n            }\n        }\n    }\n    private fun saveUserToFirebaseAndRoom(\n        userId: String,\n        nickname: String?,\n        email: String?,\n        profileImageUrl: String?)\n    {\n        // 1. Firebase 저장\n        val user = User(userId, nickname, email, profileImageUrl)\n        val userRef = FirebaseDatabase.getInstance().getReference(\"users\").child(userId)\n        userRef.setValue(user)\n            .addOnSuccessListener {\n                Log.d(\"FirebaseUser\", \"Firebase에 사용자 저장 완료 ✅\")\n                Log.d(\"Login\", \"nickname = $nickname\")\n            }\n            .addOnFailureListener { e ->\n                Log.e(\"FirebaseUser\", \"Firebase 저장 실패 ❌\", e)\n            }\n\n        // 2. Room 저장\n        val userEntity = UserEntity(userId, nickname, email, profileImageUrl)\n        val userDao = RoomDatabaseInstance.getInstance(applicationContext).userDao()\n\n        lifecycleScope.launch {\n            withContext(Dispatchers.IO) {\n                userDao.insertUser(userEntity)\n            }\n            Log.d(\"RoomUser\", \"Room에 사용자 저장 완료 ✅\")\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/LoginActivity.kt b/app/src/main/java/com/example/andapp1/LoginActivity.kt
--- a/app/src/main/java/com/example/andapp1/LoginActivity.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/LoginActivity.kt	(date 1749649280488)
@@ -22,17 +22,23 @@
 import kotlinx.coroutines.launch
 import kotlinx.coroutines.withContext
 import java.security.MessageDigest
+import com.kakao.sdk.auth.model.OAuthToken
+import com.kakao.sdk.common.model.ClientError
+import com.kakao.sdk.common.model.ClientErrorCause
+import dagger.hilt.android.AndroidEntryPoint
 
 // LoginActivity.kt
+@AndroidEntryPoint
 class LoginActivity : AppCompatActivity() {
 
+    private lateinit var binding: ActivityLoginBinding
+
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
 
-        val binding = ActivityLoginBinding.inflate(layoutInflater)
+        binding = ActivityLoginBinding.inflate(layoutInflater)
         setContentView(binding.root)
         // 카카오 로그인 초기화
-        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))
         printKeyHash(this) // 👈 여기서 호출
 
         binding.kakaoLoginButton.setOnClickListener {
@@ -40,7 +46,6 @@
             if (UserApiClient.instance.isKakaoTalkLoginAvailable(this)) {
                 UserApiClient.instance.loginWithKakaoTalk(this) { token, error ->
                     if (token != null) {
-                        Log.d("Login", "토큰 받음 ✅: ${token.accessToken}")
                         fetchKakaoUserInfo()
                     } else {
                         Log.e("Login", "카카오톡 로그인 실패: ${error?.message}")
@@ -52,7 +57,6 @@
                         Log.e("Login", "카카오 계정 로그인 실패 ❌", error)
                         Toast.makeText(this, "로그인 실패: ${error.message}", Toast.LENGTH_SHORT).show()
                     } else if (token != null) {
-                        Log.d("Login", "카카오 계정 로그인 성공 ✅: ${token.accessToken}")
                         fetchKakaoUserInfo()
                     } else {
                         Log.e("Login", "로그인 실패: token도 error도 null임 ❗")
Index: app/src/main/java/com/example/andapp1/SplashActivity.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.andapp1\n\nimport android.animation.ObjectAnimator\nimport android.content.Intent\nimport android.os.Bundle\nimport android.os.Looper\nimport androidx.appcompat.app.AppCompatActivity\nimport androidx.core.content.ContextCompat.startActivity\nimport android.os.Handler\nimport android.widget.LinearLayout\nimport android.widget.TextView\nimport com.kakao.sdk.common.KakaoSdk\nimport com.kakao.sdk.user.UserApiClient\n\nclass SplashActivity : AppCompatActivity() {\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))\n        setContentView(R.layout.splash_activity)\n\n        val appTitle = findViewById<TextView>(R.id.tvAppTitle)\n        val slogan = findViewById<TextView>(R.id.tvSlogan)\n        appTitle.alpha = 0f\n        slogan.alpha = 0f\n\n        // 2. Fade-in 애니메이션 (2초동안 0→2)\n        ObjectAnimator.ofFloat(appTitle, \"alpha\", 0f, 1f).apply {\n            duration = 2000 // 2초\n            start()\n        }\n\n        appTitle.postDelayed({\n            ObjectAnimator.ofFloat(slogan, \"alpha\", 0f, 1f).apply {\n                duration = 1000 // 1초\n                start()\n            }\n        }, 1000) // 1초 후 실행\n\n        // 화면 전체 터치 시 LoginActivity로 이동\n        val rootView = findViewById<LinearLayout>(R.id.splashRoot)\n        rootView.setOnClickListener {\n            checkAutoLogin()\n        }\n    }\n    private fun checkAutoLogin() {\n        // 카카오톡 자동 로그인/토큰 체크\n        UserApiClient.instance.accessTokenInfo { tokenInfo, error ->\n            if (error != null) {\n                // 토큰이 없거나 만료: 로그인 화면으로 이동\n                startActivity(Intent(this, LoginActivity::class.java))\n            } else if (tokenInfo != null) {\n                // 토큰 유효: 바로 메인화면으로 이동\n                startActivity(Intent(this, MainActivity::class.java))\n            }\n            finish()\n        }\n    }\n}\n\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/SplashActivity.kt b/app/src/main/java/com/example/andapp1/SplashActivity.kt
--- a/app/src/main/java/com/example/andapp1/SplashActivity.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/SplashActivity.kt	(date 1749649288024)
@@ -11,11 +11,13 @@
 import android.widget.TextView
 import com.kakao.sdk.common.KakaoSdk
 import com.kakao.sdk.user.UserApiClient
+import com.google.firebase.auth.FirebaseAuth
+import dagger.hilt.android.AndroidEntryPoint
 
+@AndroidEntryPoint
 class SplashActivity : AppCompatActivity() {
     override fun onCreate(savedInstanceState: Bundle?) {
         super.onCreate(savedInstanceState)
-        KakaoSdk.init(this, getString(R.string.kakao_native_app_key))
         setContentView(R.layout.splash_activity)
 
         val appTitle = findViewById<TextView>(R.id.tvAppTitle)
Index: gradle.properties
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+># Project-wide Gradle settings.\n# IDE (e.g. Android Studio) users:\n# Gradle settings configured through the IDE *will override*\n# any settings specified in this file.\n# For more details on how to configure your build environment visit\n# http://www.gradle.org/docs/current/userguide/build_environment.html\n# Specifies the JVM arguments used for the daemon process.\n# The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx2048m -Dfile.encoding=UTF-8\n# When configured, Gradle will run in incubating parallel mode.\n# This option should only be used with decoupled projects. For more details, visit\n# https://developer.android.com/r/tools/gradle-multi-project-decoupled-projects\n# org.gradle.parallel=true\n# AndroidX package structure to make it clearer which packages are bundled with the\n# Android operating system, and which are packaged with your app's APK\n# https://developer.android.com/topic/libraries/support-library/androidx-rn\nandroid.useAndroidX=true\n# Kotlin code style for this project: \"official\" or \"obsolete\":\nkotlin.code.style=official\nkotlin.incremental=false\nkotlin.caching.enabled=false\n# Enables namespacing of each library's R class so that its R class includes only the\n# resources declared in the library itself and none from the library's dependencies,\n# thereby reducing the size of the R class for that library\nandroid.nonTransitiveRClass=true\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>ISO-8859-1
===================================================================
diff --git a/gradle.properties b/gradle.properties
--- a/gradle.properties	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/gradle.properties	(date 1749651771669)
@@ -17,9 +17,11 @@
 android.useAndroidX=true
 # Kotlin code style for this project: "official" or "obsolete":
 kotlin.code.style=official
-kotlin.incremental=false
-kotlin.caching.enabled=false
 # Enables namespacing of each library's R class so that its R class includes only the
 # resources declared in the library itself and none from the library's dependencies,
 # thereby reducing the size of the R class for that library
 android.nonTransitiveRClass=true
+# Suppress warning for compileSdk 35
+android.suppressUnsupportedCompileSdk=35
+# KSP settings
+ksp.incremental=false
Index: app/src/main/java/com/example/andapp1/RoomRepository.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>//RoomRepository.kt\npackage com.example.andapp1\n\nimport androidx.lifecycle.LiveData\nimport androidx.room.Query\n\n// ✅ 완료\n\nimport com.example.andapp1.AppDatabase\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.withContext\nimport com.example.andapp1.RoomDao\nclass RoomRepository(private val db: AppDatabase) {\n    private val roomDao = db.roomDao()  // ✅ 여기가 문제면 수정 필요\n    @Query(\"SELECT * FROM favorite_rooms ORDER BY lastActivityTime DESC\")\n\n    fun getAllFavoriteRooms(): LiveData<List<RoomEntity>> {\n        return db.roomDao().getAllFavoriteRooms()\n    }\n    suspend fun getAllFavoriteRoomEntities(): List<RoomEntity> {\n        return roomDao.getAllFavoriteRoomsRaw() // 아래 쿼리도 필요\n    }\n    suspend fun getFavoriteRoomCodes(): List<String> {\n        return roomDao.getAllFavoriteRoomsRaw().map { it.roomCode }\n    }\n    suspend fun insertFavoriteRoom(room: RoomEntity) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().insertFavoriteRoom(room)\n        }\n    }\n\n    suspend fun deleteFavoriteRoom(room: RoomEntity) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().deleteFavoriteRoom(room)\n        }\n    }\n\n    suspend fun deleteRoomByCode(roomCode: String) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().deleteRoomByCode(roomCode)\n        }\n    }\n\n    suspend fun updateRoomTitle(roomCode: String, newTitle: String) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().updateRoomTitle(roomCode, newTitle)\n        }\n    }\n\n    suspend fun updateFavoriteStatus(roomCode: String, isFavorite: Boolean) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().updateFavoriteStatus(roomCode, isFavorite)\n        }\n    }\n\n    suspend fun updateLastActivityTime(roomCode: String, newTime: String) {\n        withContext(Dispatchers.IO) {\n            db.roomDao().updateLastActivityTime(roomCode, newTime)\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/RoomRepository.kt b/app/src/main/java/com/example/andapp1/RoomRepository.kt
--- a/app/src/main/java/com/example/andapp1/RoomRepository.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/RoomRepository.kt	(date 1749648735857)
@@ -1,61 +1,129 @@
 //RoomRepository.kt
 package com.example.andapp1
 
-import androidx.lifecycle.LiveData
-import androidx.room.Query
-
-// ✅ 완료
-
-import com.example.andapp1.AppDatabase
+import android.util.Log
+import com.google.firebase.database.*
 import kotlinx.coroutines.Dispatchers
+import kotlinx.coroutines.channels.awaitClose
+import kotlinx.coroutines.flow.Flow
+import kotlinx.coroutines.flow.callbackFlow
+import kotlinx.coroutines.launch
+import kotlinx.coroutines.tasks.await
 import kotlinx.coroutines.withContext
+import java.util.*
+
+// ✅ 완료
+
+import com.example.andapp1.AppDatabase
 import com.example.andapp1.RoomDao
+
 class RoomRepository(private val db: AppDatabase) {
-    private val roomDao = db.roomDao()  // ✅ 여기가 문제면 수정 필요
-    @Query("SELECT * FROM favorite_rooms ORDER BY lastActivityTime DESC")
+    private val roomDao = db.roomDao()
+    private val roomsRef: DatabaseReference = FirebaseDatabase.getInstance("https://andapp1-bcb40-default-rtdb.firebaseio.com/").getReference("rooms")
+    private val usersRef: DatabaseReference = FirebaseDatabase.getInstance("https://andapp1-bcb40-default-rtdb.firebaseio.com/").getReference("users")
 
-    fun getAllFavoriteRooms(): LiveData<List<RoomEntity>> {
-        return db.roomDao().getAllFavoriteRooms()
-    }
-    suspend fun getAllFavoriteRoomEntities(): List<RoomEntity> {
-        return roomDao.getAllFavoriteRoomsRaw() // 아래 쿼리도 필요
-    }
-    suspend fun getFavoriteRoomCodes(): List<String> {
-        return roomDao.getAllFavoriteRoomsRaw().map { it.roomCode }
+    fun getRoomsStream(userId: String): Flow<List<Room>> = callbackFlow {
+        val listener = object : ValueEventListener {
+            override fun onDataChange(snapshot: DataSnapshot) {
+                val rooms = mutableListOf<Room>()
+                val job = launch {
+                    val favoriteCodes = roomDao.getFavoriteRoomCodes().toSet()
+                    for (roomSnapshot in snapshot.children) {
+                        if (roomSnapshot.child("participants").hasChild(userId)) {
+                            roomSnapshot.getValue(Room::class.java)?.let { room ->
+                                room.isFavorite = favoriteCodes.contains(room.roomCode)
+                                rooms.add(room)
+                            }
+                        }
+                    }
+                    // Sort by favorite and then by last activity time
+                    val sortedRooms = rooms.sortedWith(compareByDescending<Room> { it.isFavorite }.thenByDescending { it.lastActivityTime })
+                    trySend(sortedRooms).isSuccess
+                }
+            }
+
+            override fun onCancelled(error: DatabaseError) {
+                Log.e("RoomRepository", "Failed to read rooms.", error.toException())
+                close(error.toException())
+            }
+        }
+        roomsRef.addValueEventListener(listener)
+        awaitClose { roomsRef.removeEventListener(listener) }
     }
-    suspend fun insertFavoriteRoom(room: RoomEntity) {
+
+    suspend fun createRoom(room: Room, userId: String, author: Author) {
         withContext(Dispatchers.IO) {
-            db.roomDao().insertFavoriteRoom(room)
+            roomsRef.child(room.roomCode).setValue(room).await()
+            addParticipant(room.roomCode, userId, author)
         }
     }
-
-    suspend fun deleteFavoriteRoom(room: RoomEntity) {
+    
+    suspend fun addParticipant(roomCode: String, userId: String, author: Author) {
         withContext(Dispatchers.IO) {
-            db.roomDao().deleteFavoriteRoom(room)
+            val participantData = mapOf("nickname" to author.name)
+            roomsRef.child(roomCode).child("participants").child(userId).setValue(participantData).await()
         }
     }
-
-    suspend fun deleteRoomByCode(roomCode: String) {
+    
+    suspend fun leaveRoom(roomCode: String, userId: String, author: Author) {
         withContext(Dispatchers.IO) {
-            db.roomDao().deleteRoomByCode(roomCode)
+            sendSystemMessage(roomCode, "👋 ${author.name} left the chat room.")
+            roomsRef.child(roomCode).child("participants").child(userId).removeValue().await()
+            roomDao.deleteRoomByCode(roomCode)
+            
+            // Check if the room is empty to delete it from Firebase
+            val participantsSnapshot = roomsRef.child(roomCode).child("participants").get().await()
+            if (!participantsSnapshot.hasChildren()) {
+                roomsRef.child(roomCode).removeValue().await()
+                FirebaseDatabase.getInstance().getReference("messages").child(roomCode).removeValue().await()
+            }
         }
     }
-
-    suspend fun updateRoomTitle(roomCode: String, newTitle: String) {
+    
+    suspend fun updateRoomName(roomCode: String, newName: String, author: Author) {
         withContext(Dispatchers.IO) {
-            db.roomDao().updateRoomTitle(roomCode, newTitle)
+            val oldName = roomsRef.child(roomCode).child("roomTitle").get().await().getValue(String::class.java) ?: "Unknown"
+            roomsRef.child(roomCode).child("roomTitle").setValue(newName).await()
+            roomDao.updateRoomTitle(roomCode, newName)
+            sendSystemMessage(roomCode, "⚙️ ${author.name} changed the chat room name from '$oldName' to '$newName'.")
         }
     }
-
-    suspend fun updateFavoriteStatus(roomCode: String, isFavorite: Boolean) {
+    
+    suspend fun toggleFavoriteStatus(room: Room) {
         withContext(Dispatchers.IO) {
-            db.roomDao().updateFavoriteStatus(roomCode, isFavorite)
+            val isFavorite = !room.isFavorite
+            room.isFavorite = isFavorite
+            val roomEntity = RoomEntity(
+                roomCode = room.roomCode,
+                roomTitle = room.roomTitle,
+                lastActivityTime = room.lastActivityTime,
+                isFavorite = isFavorite
+            )
+            if (isFavorite) {
+                roomDao.insertFavoriteRoom(roomEntity)
+            } else {
+                roomDao.deleteFavoriteRoom(roomEntity)
+            }
         }
     }
 
-    suspend fun updateLastActivityTime(roomCode: String, newTime: String) {
-        withContext(Dispatchers.IO) {
-            db.roomDao().updateLastActivityTime(roomCode, newTime)
+    private suspend fun sendSystemMessage(roomCode: String, text: String) {
+        val message = ChatMessage(
+            text = text,
+            user = Author(id = "system", name = "System", avatar = null),
+            createdAt = Date()
+        )
+        val messageId = FirebaseDatabase.getInstance().getReference("messages").child(roomCode).push().key ?: ""
+        FirebaseDatabase.getInstance().getReference("messages").child(roomCode).child(messageId).setValue(message).await()
+    }
+
+    suspend fun getRoomInfo(roomCode: String): Room? {
+        return try {
+            withContext(Dispatchers.IO) {
+                roomsRef.child(roomCode).get().await().getValue(Room::class.java)
+            }
+        } catch (e: Exception) {
+            null
         }
     }
 }
\ No newline at end of file
Index: app/src/main/res/values/strings.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><resources>\n    <string name=\"app_name\">Travel Maker</string>\n    <string name=\"kakao_native_app_key\">ffb04602d82950f1b00de0324a38f023</string>\n    <string name=\"messages_list_description\">채팅 메시지 목록</string>\n    <string name=\"send_photo\">사진 보내기</string>\n    <string name=\"image_message\">이미지 메시지</string>\n\n\n</resources>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/res/values/strings.xml b/app/src/main/res/values/strings.xml
--- a/app/src/main/res/values/strings.xml	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/res/values/strings.xml	(date 1749647575036)
@@ -1,6 +1,5 @@
 <resources>
     <string name="app_name">Travel Maker</string>
-    <string name="kakao_native_app_key">ffb04602d82950f1b00de0324a38f023</string>
     <string name="messages_list_description">채팅 메시지 목록</string>
     <string name="send_photo">사진 보내기</string>
     <string name="image_message">이미지 메시지</string>
Index: app/src/main/java/com/example/andapp1/MainViewModel.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.andapp1\n\nimport android.content.Context\nimport android.util.Log\nimport androidx.lifecycle.LiveData\nimport androidx.lifecycle.MutableLiveData\nimport androidx.lifecycle.ViewModel\nimport androidx.lifecycle.ViewModelProvider\nimport androidx.lifecycle.viewModelScope\nimport com.google.firebase.database.DataSnapshot\nimport com.google.firebase.database.DatabaseError\nimport com.google.firebase.database.FirebaseDatabase\nimport com.google.firebase.database.ValueEventListener\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.launch\nimport kotlinx.coroutines.withContext\n\n// MainViewModel.kt\nclass MainViewModel(\n    private val repository: RoomRepository,\n    private val context: Context\n) : ViewModel() {\n\n    private var currentUserId: String? = null\n\n    private val _rooms = MutableLiveData<List<Room>>()\n    val rooms: LiveData<List<Room>> = _rooms\n\n    private var favoriteRoomCodes = setOf<String>()\n\n    init {\n        loadFavoriteRoomCodes()\n    }\n\n    fun setCurrentUserId(userId: String) {\n        currentUserId = userId\n    }\n\n    private fun loadFavoriteRoomCodes() {\n        viewModelScope.launch {\n            favoriteRoomCodes = repository.getFavoriteRoomCodes().toSet()\n        }\n    }\n\n    fun loadRooms(userId: String) {\n        FirebaseRoomManager.getRooms(userId) { roomsList ->\n            viewModelScope.launch {\n                // 즐겨찾기 상태 동기화\n                val roomsWithFavorites = roomsList.map { room ->\n                    room.copy(isFavorite = favoriteRoomCodes.contains(room.roomCode))\n                }\n                _rooms.postValue(roomsWithFavorites)\n            }\n        }\n    }\n\n    fun updateRoomsList(roomsList: List<Room>) {\n        viewModelScope.launch {\n            // 즐겨찾기 상태 동기화\n            val roomsWithFavorites = roomsList.map { room ->\n                room.copy(isFavorite = favoriteRoomCodes.contains(room.roomCode))\n            }\n            _rooms.postValue(roomsWithFavorites)\n        }\n    }\n\n    fun checkFavoriteStatus(room: Room) {\n        room.isFavorite = favoriteRoomCodes.contains(room.roomCode)\n    }\n\n    fun createRoomWithParticipant(room: Room, userId: String) {\n        // Firebase에 방 생성\n        FirebaseRoomManager.createRoom(room)\n        // 생성자를 참여자로 추가\n        FirebaseRoomManager.addParticipant(room.roomCode, userId)\n    }\n\n    fun addRoom(room: Room) {\n        currentUserId?.let { userId ->\n            // Firebase에 참여자 추가\n            FirebaseRoomManager.addParticipant(room.roomCode, userId)\n        }\n    }\n\n    fun changeRoomName(roomCode: String, newName: String, author: Author) {\n        FirebaseRoomManager.updateRoomName(roomCode, newName, author)\n\n        // 로컬 DB도 업데이트\n        viewModelScope.launch {\n            repository.updateRoomTitle(roomCode, newName)\n        }\n    }\n\n    fun leaveRoom(roomCode: String, userId: String) {\n        viewModelScope.launch {\n            try {\n                // 1. 나가기 메시지 전송\n                val prefs = context.getSharedPreferences(\"login\", Context.MODE_PRIVATE)\n                val nickname = prefs.getString(\"nickname\", \"Unknown\") ?: \"Unknown\"\n                val author = Author(userId, nickname)\n                FirebaseRoomManager.sendLeaveMessage(roomCode, author)\n\n                // 2. Firebase에서 참여자 제거\n                FirebaseRoomManager.removeParticipant(roomCode, userId)\n\n                // 3. 로컬 즐겨찾기에서도 제거\n                repository.deleteRoomByCode(roomCode)\n\n                // 4. 즐겨찾기 목록 갱신\n                loadFavoriteRoomCodes()\n\n                // 5. UI 즉시 업데이트\n                val currentRooms = _rooms.value?.toMutableList() ?: mutableListOf()\n                currentRooms.removeAll { it.roomCode == roomCode }\n                _rooms.postValue(currentRooms)\n\n                Log.d(\"MainViewModel\", \"✅ 채팅방 나가기 완료: $roomCode\")\n            } catch (e: Exception) {\n                Log.e(\"MainViewModel\", \"❌ 채팅방 나가기 실패\", e)\n            }\n        }\n    }\n\n    fun updateLastActivityTime(roomCode: String, newTime: String) {\n        FirebaseRoomManager.updateLastActivityTime(roomCode, newTime)\n\n        viewModelScope.launch {\n            repository.updateLastActivityTime(roomCode, newTime)\n        }\n    }\n\n    fun insertFavoriteRoom(room: RoomEntity) {\n        viewModelScope.launch {\n            repository.insertFavoriteRoom(room)\n            favoriteRoomCodes = favoriteRoomCodes + room.roomCode\n\n            // UI 즉시 업데이트\n            val currentRooms = _rooms.value?.map {\n                if (it.roomCode == room.roomCode) {\n                    it.copy(isFavorite = true)\n                } else it\n            }\n            currentRooms?.let { _rooms.postValue(it) }\n        }\n    }\n\n    fun deleteFavoriteRoom(room: RoomEntity) {\n        viewModelScope.launch {\n            repository.deleteFavoriteRoom(room)\n            favoriteRoomCodes = favoriteRoomCodes - room.roomCode\n\n            // UI 즉시 업데이트\n            val currentRooms = _rooms.value?.map {\n                if (it.roomCode == room.roomCode) {\n                    it.copy(isFavorite = false)\n                } else it\n            }\n            currentRooms?.let { _rooms.postValue(it) }\n        }\n    }\n\n    fun generateRoomLink(roomCode: String): String {\n        return \"https://andapp1.com/join?code=$roomCode\"\n    }\n\n    // ✅ 두 가지 형식 모두 허용하도록 수정\n    fun isRoomCode(input: String): Boolean {\n        return input.matches(Regex(\"[A-Z0-9]{3}-[A-Z0-9]{3}\")) ||  // ABC-123 형식\n                input.matches(Regex(\"[A-Z0-9]{6}\"))                 // ABC123 형식\n    }\n\n    fun isRoomLink(input: String): Boolean {\n        return input.startsWith(\"https://andapp1.com/join?code=\")\n    }\n\n    fun extractRoomCodeFromLink(link: String): String? {\n        return try {\n            val uri = android.net.Uri.parse(link)\n            uri.getQueryParameter(\"code\")?.uppercase()\n        } catch (e: Exception) {\n            null\n        }\n    }\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/andapp1/MainViewModel.kt b/app/src/main/java/com/example/andapp1/MainViewModel.kt
--- a/app/src/main/java/com/example/andapp1/MainViewModel.kt	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/app/src/main/java/com/example/andapp1/MainViewModel.kt	(date 1749650305689)
@@ -1,184 +1,39 @@
 package com.example.andapp1
 
-import android.content.Context
-import android.util.Log
-import androidx.lifecycle.LiveData
-import androidx.lifecycle.MutableLiveData
-import androidx.lifecycle.ViewModel
-import androidx.lifecycle.ViewModelProvider
-import androidx.lifecycle.viewModelScope
-import com.google.firebase.database.DataSnapshot
-import com.google.firebase.database.DatabaseError
-import com.google.firebase.database.FirebaseDatabase
-import com.google.firebase.database.ValueEventListener
-import kotlinx.coroutines.Dispatchers
+import android.content.Intent
+import android.os.Bundle
+import androidx.activity.viewModels
+import androidx.appcompat.app.AppCompatActivity
+import androidx.lifecycle.lifecycleScope
+import com.example.andapp1.databinding.ActivityMainBinding
+import dagger.hilt.android.AndroidEntryPoint
+import kotlinx.coroutines.flow.collectLatest
 import kotlinx.coroutines.launch
-import kotlinx.coroutines.withContext
-
-// MainViewModel.kt
-class MainViewModel(
-    private val repository: RoomRepository,
-    private val context: Context
-) : ViewModel() {
-
-    private var currentUserId: String? = null
-
-    private val _rooms = MutableLiveData<List<Room>>()
-    val rooms: LiveData<List<Room>> = _rooms
 
-    private var favoriteRoomCodes = setOf<String>()
+@AndroidEntryPoint
+class MainActivity : AppCompatActivity() {
 
-    init {
-        loadFavoriteRoomCodes()
-    }
+    private lateinit var binding: ActivityMainBinding
+    private val viewModel: MainViewModel by viewModels()
 
-    fun setCurrentUserId(userId: String) {
-        currentUserId = userId
-    }
-
-    private fun loadFavoriteRoomCodes() {
-        viewModelScope.launch {
-            favoriteRoomCodes = repository.getFavoriteRoomCodes().toSet()
-        }
-    }
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        binding = ActivityMainBinding.inflate(layoutInflater)
+        setContentView(binding.root)
 
-    fun loadRooms(userId: String) {
-        FirebaseRoomManager.getRooms(userId) { roomsList ->
-            viewModelScope.launch {
-                // 즐겨찾기 상태 동기화
-                val roomsWithFavorites = roomsList.map { room ->
-                    room.copy(isFavorite = favoriteRoomCodes.contains(room.roomCode))
-                }
-                _rooms.postValue(roomsWithFavorites)
-            }
+        val adapter = ChatRoomAdapter { chatRoom ->
+            val intent = Intent(this, ChatActivity::class.java)
+            intent.putExtra("chatRoomId", chatRoom.roomId)
+            intent.putExtra("chatRoomName", chatRoom.name)
+            startActivity(intent)
         }
-    }
 
-    fun updateRoomsList(roomsList: List<Room>) {
-        viewModelScope.launch {
-            // 즐겨찾기 상태 동기화
-            val roomsWithFavorites = roomsList.map { room ->
-                room.copy(isFavorite = favoriteRoomCodes.contains(room.roomCode))
-            }
-            _rooms.postValue(roomsWithFavorites)
-        }
-    }
+        binding.recyclerView.adapter = adapter
 
-    fun checkFavoriteStatus(room: Room) {
-        room.isFavorite = favoriteRoomCodes.contains(room.roomCode)
-    }
-
-    fun createRoomWithParticipant(room: Room, userId: String) {
-        // Firebase에 방 생성
-        FirebaseRoomManager.createRoom(room)
-        // 생성자를 참여자로 추가
-        FirebaseRoomManager.addParticipant(room.roomCode, userId)
-    }
-
-    fun addRoom(room: Room) {
-        currentUserId?.let { userId ->
-            // Firebase에 참여자 추가
-            FirebaseRoomManager.addParticipant(room.roomCode, userId)
-        }
-    }
-
-    fun changeRoomName(roomCode: String, newName: String, author: Author) {
-        FirebaseRoomManager.updateRoomName(roomCode, newName, author)
-
-        // 로컬 DB도 업데이트
-        viewModelScope.launch {
-            repository.updateRoomTitle(roomCode, newName)
-        }
-    }
-
-    fun leaveRoom(roomCode: String, userId: String) {
-        viewModelScope.launch {
-            try {
-                // 1. 나가기 메시지 전송
-                val prefs = context.getSharedPreferences("login", Context.MODE_PRIVATE)
-                val nickname = prefs.getString("nickname", "Unknown") ?: "Unknown"
-                val author = Author(userId, nickname)
-                FirebaseRoomManager.sendLeaveMessage(roomCode, author)
-
-                // 2. Firebase에서 참여자 제거
-                FirebaseRoomManager.removeParticipant(roomCode, userId)
-
-                // 3. 로컬 즐겨찾기에서도 제거
-                repository.deleteRoomByCode(roomCode)
-
-                // 4. 즐겨찾기 목록 갱신
-                loadFavoriteRoomCodes()
-
-                // 5. UI 즉시 업데이트
-                val currentRooms = _rooms.value?.toMutableList() ?: mutableListOf()
-                currentRooms.removeAll { it.roomCode == roomCode }
-                _rooms.postValue(currentRooms)
-
-                Log.d("MainViewModel", "✅ 채팅방 나가기 완료: $roomCode")
-            } catch (e: Exception) {
-                Log.e("MainViewModel", "❌ 채팅방 나가기 실패", e)
-            }
-        }
-    }
-
-    fun updateLastActivityTime(roomCode: String, newTime: String) {
-        FirebaseRoomManager.updateLastActivityTime(roomCode, newTime)
-
-        viewModelScope.launch {
-            repository.updateLastActivityTime(roomCode, newTime)
-        }
-    }
-
-    fun insertFavoriteRoom(room: RoomEntity) {
-        viewModelScope.launch {
-            repository.insertFavoriteRoom(room)
-            favoriteRoomCodes = favoriteRoomCodes + room.roomCode
-
-            // UI 즉시 업데이트
-            val currentRooms = _rooms.value?.map {
-                if (it.roomCode == room.roomCode) {
-                    it.copy(isFavorite = true)
-                } else it
-            }
-            currentRooms?.let { _rooms.postValue(it) }
-        }
-    }
-
-    fun deleteFavoriteRoom(room: RoomEntity) {
-        viewModelScope.launch {
-            repository.deleteFavoriteRoom(room)
-            favoriteRoomCodes = favoriteRoomCodes - room.roomCode
-
-            // UI 즉시 업데이트
-            val currentRooms = _rooms.value?.map {
-                if (it.roomCode == room.roomCode) {
-                    it.copy(isFavorite = false)
-                } else it
-            }
-            currentRooms?.let { _rooms.postValue(it) }
-        }
-    }
-
-    fun generateRoomLink(roomCode: String): String {
-        return "https://andapp1.com/join?code=$roomCode"
-    }
-
-    // ✅ 두 가지 형식 모두 허용하도록 수정
-    fun isRoomCode(input: String): Boolean {
-        return input.matches(Regex("[A-Z0-9]{3}-[A-Z0-9]{3}")) ||  // ABC-123 형식
-                input.matches(Regex("[A-Z0-9]{6}"))                 // ABC123 형식
-    }
-
-    fun isRoomLink(input: String): Boolean {
-        return input.startsWith("https://andapp1.com/join?code=")
-    }
-
-    fun extractRoomCodeFromLink(link: String): String? {
-        return try {
-            val uri = android.net.Uri.parse(link)
-            uri.getQueryParameter("code")?.uppercase()
-        } catch (e: Exception) {
-            null
+        lifecycleScope.launch {
+            viewModel.chatRooms.collectLatest { chatRooms ->
+                adapter.submitList(chatRooms)
+            }
         }
     }
 }
\ No newline at end of file
Index: .idea/deploymentTargetSelector.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project version=\"4\">\n  <component name=\"deploymentTargetSelector\">\n    <selectionStates>\n      <SelectionState runConfigName=\"app\">\n        <option name=\"selectionMode\" value=\"DROPDOWN\" />\n        <DropdownSelection timestamp=\"2025-06-09T08:06:39.906309Z\">\n        <DropdownSelection timestamp=\"2025-06-09T07:23:47.150837500Z\">\n          <Target type=\"DEFAULT_BOOT\">\n            <handle>\n              <DeviceId pluginId=\"PhysicalDevice\" identifier=\"serial=R3CW50MMF0X\" />\n            </handle>\n          </Target>\n        </DropdownSelection>\n        <DialogSelection />\n      </SelectionState>\n    </selectionStates>\n  </component>\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/deploymentTargetSelector.xml b/.idea/deploymentTargetSelector.xml
--- a/.idea/deploymentTargetSelector.xml	(revision 43e2b34ef5f68bf7dcaaf1fd3b85882db12fd7d8)
+++ b/.idea/deploymentTargetSelector.xml	(date 1749570964449)
@@ -4,15 +4,6 @@
     <selectionStates>
       <SelectionState runConfigName="app">
         <option name="selectionMode" value="DROPDOWN" />
-        <DropdownSelection timestamp="2025-06-09T08:06:39.906309Z">
-        <DropdownSelection timestamp="2025-06-09T07:23:47.150837500Z">
-          <Target type="DEFAULT_BOOT">
-            <handle>
-              <DeviceId pluginId="PhysicalDevice" identifier="serial=R3CW50MMF0X" />
-            </handle>
-          </Target>
-        </DropdownSelection>
-        <DialogSelection />
       </SelectionState>
     </selectionStates>
   </component>
diff --git a/app/src/main/java/com/example/andapp1/EnterLinkActivity.kt b/app/src/main/java/com/example/andapp1/EnterLinkActivity.kt
deleted file mode 100644
diff --git a/app/src/main/java/com/example/andapp1/EnterCodeActivity.kt b/app/src/main/java/com/example/andapp1/EnterCodeActivity.kt
deleted file mode 100644
